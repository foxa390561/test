<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Пример HTML Индекса</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        pre {
            background-color: #eaeaea;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>

    <pre>
       Структура проекта:
Scripts/
    ├── Character.meta
    ├── ItemSys.meta
    ├── SaveSys.meta
    ├── TerrainManager.cs
    ├── TerrainManager.cs.meta
    ├── Utils.meta
    └── VoxelSys.meta
    └── Character/
        ├── CameraController.cs
        ├── CameraController.cs.meta
        ├── Interaction.meta
        ├── PlayerBumper.cs
        ├── PlayerBumper.cs.meta
        ├── PlayerController.cs
        ├── PlayerController.cs.meta
        ├── PlayerManager.cs
        ├── PlayerManager.cs.meta
        ├── PlayerStats.cs
        ├── PlayerStats.cs.meta
        ├── SceneStarter.cs
        ├── SceneStarter.cs.meta
        ├── VoxelPlacer.cs
        └── VoxelPlacer.cs.meta
        └── Interaction/
            ├── IInteractable.cs
            ├── IInteractable.cs.meta
            ├── InteractionManager.cs
            ├── InteractionManager.cs.meta
            ├── PlayerInteraction.cs
            └── PlayerInteraction.cs.meta
    └── ItemSys/
        ├── Containers.meta
        ├── ItemDatabase.cs
        ├── ItemDatabase.cs.meta
        ├── ItemStack.cs
        ├── ItemStack.cs.meta
        ├── ItemTypes.meta
        ├── ItemUtil.cs
        ├── ItemUtil.cs.meta
        ├── SpawnManager.cs
        ├── SpawnManager.cs.meta
        ├── UI.meta
        └── WorldObjects.meta
        └── Containers/
            ├── ContainerManager.cs
            ├── ContainerManager.cs.meta
            ├── Inventory.cs
            ├── Inventory.cs.meta
            ├── ItemContainer.cs
            ├── ItemContainer.cs.meta
            ├── ItemStash.cs
            └── ItemStash.cs.meta
        └── ItemTypes/
            ├── Block.cs
            ├── Block.cs.meta
            ├── Equiment.cs
            ├── Equiment.cs.meta
            ├── Item.cs
            ├── Item.cs.meta
            ├── NPC.cs
            └── NPC.cs.meta
        └── UI/
            ├── EquipmentSlot.cs
            ├── EquipmentSlot.cs.meta
            ├── ImageController.cs
            ├── ImageController.cs.meta
            ├── ItemSlot.cs
            ├── ItemSlot.cs.meta
            ├── Tooltip.cs
            ├── Tooltip.cs.meta
            ├── UIUtil.cs
            └── UIUtil.cs.meta
        └── WorldObjects/
            ├── WorldObject.cs
            └── WorldObject.cs.meta
    └── SaveSys/
        ├── DataClasses.meta
        ├── LoadMenu.cs
        ├── LoadMenu.cs.meta
        ├── NewSaveMenu.cs
        ├── NewSaveMenu.cs.meta
        ├── PauseMenu.cs
        ├── PauseMenu.cs.meta
        ├── SaveManager.cs
        ├── SaveManager.cs.meta
        ├── SaveMenu.cs
        ├── SaveMenu.cs.meta
        ├── SaveUtil.cs
        └── SaveUtil.cs.meta
        └── DataClasses/
            ├── WorldPlacementData.cs
            └── WorldPlacementData.cs.meta
    └── Utils/
        ├── CollisionChecker.cs
        ├── CollisionChecker.cs.meta
        ├── Main.meta
        ├── MouseHandler.cs
        ├── MouseHandler.cs.meta
        ├── NativeCounter.cs
        ├── NativeCounter.cs.meta
        ├── NativeHelper.cs
        ├── NativeHelper.cs.meta
        ├── NoAllocHelpers.cs
        ├── NoAllocHelpers.cs.meta
        ├── Noise.cs
        ├── Noise.cs.meta
        ├── PriorityQueue.meta
        ├── SerializePropertyReadOnly.cs
        ├── SerializePropertyReadOnly.cs.meta
        ├── Singleton.cs
        └── Singleton.cs.meta
        └── Main/
            ├── Consts.cs
            ├── Consts.cs.meta
            ├── GameController.cs
            ├── GameController.cs.meta
            ├── GameEvents.cs
            └── GameEvents.cs.meta
        └── PriorityQueue/
            ├── FastPriorityQueue.cs
            ├── FastPriorityQueue.cs.meta
            ├── FastPriorityQueueNode.cs
            ├── FastPriorityQueueNode.cs.meta
            ├── GenericPriorityQueue.cs
            ├── GenericPriorityQueue.cs.meta
            ├── GenericPriorityQueueNode.cs
            ├── GenericPriorityQueueNode.cs.meta
            ├── IFixedSizePriorityQueue.cs
            ├── IFixedSizePriorityQueue.cs.meta
            ├── IPriorityQueue.cs
            ├── IPriorityQueue.cs.meta
            ├── SimplePriorityQueue.cs
            ├── SimplePriorityQueue.cs.meta
            ├── StablePriorityQueue.cs
            ├── StablePriorityQueue.cs.meta
            ├── StablePriorityQueueNode.cs
            └── StablePriorityQueueNode.cs.meta
    └── VoxelSys/
        ├── Chunk.cs
        ├── Chunk.cs.meta
        ├── ChunkColliderBuilder.cs
        ├── ChunkColliderBuilder.cs.meta
        ├── ChunkMeshBuilder.cs
        ├── ChunkMeshBuilder.cs.meta
        ├── ChunkObjectSpawner.cs
        ├── ChunkObjectSpawner.cs.meta
        ├── ChunkPersistance.cs
        ├── ChunkPersistance.cs.meta
        ├── NoiseGenerator.cs
        ├── NoiseGenerator.cs.meta
        ├── TerrainPersistance.cs
        ├── TerrainPersistance.cs.meta
        ├── Voxel.cs
        ├── Voxel.cs.meta
        ├── VoxelUtil.cs
        └── VoxelUtil.cs.meta


Скрипты:
Script: TerrainManager.cs (D:/Unity Project/Testgame/Assets/Scripts\TerrainManager.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using Priority_Queue;
using UnityEngine;

public partial class TerrainManager : Singleton<TerrainManager>
{
    [SerializeField] Transform target; // Player
    Vector3Int chunkSize = Consts.ChunkSize;
    [SerializeField] Vector2Int chunkSpawnSize = Vector2Int.one * 3;
    [SerializeField] Material chunkMaterial;
    [SerializeField] int maxGenerateChunksInFrame = 5;
    [SerializeField] ChunkMeshBuilder.SimplifyingMethod simplifyingMethod;

    bool initialized;
    public event EmptyDel OnInitializeTerrain;

    class ChunkNode : FastPriorityQueueNode
    {
        public Vector3Int chunkPosition;
    } 
    
    Dictionary<Vector3Int, Chunk> chunks = new Dictionary<Vector3Int, Chunk>();
    Vector3Int currentTargetChunkPosition = new Vector3Int(int.MinValue, int.MaxValue, int.MinValue);
    //Queue<ChunkNode> generateChunkQueue = new Queue<ChunkNode>();
    FastPriorityQueue<ChunkNode> generateChunkQueue = new FastPriorityQueue<ChunkNode>(100000);
    int updatingChunks;

    public Vector3Int ChunkSize => chunkSize;
    public Material ChunkMaterial => chunkMaterial;
    public ChunkMeshBuilder.SimplifyingMethod SimplifyingMethod => simplifyingMethod;

    public int UpdatingChunks
    {
        get => updatingChunks;
        set => updatingChunks = value;
    }

    public bool CanUpdate => updatingChunks <= maxGenerateChunksInFrame;

    void Awake()
    {
        ChunkMeshBuilder.InitializeShaderParameter();
    }

    void Update()
    {
        if (target == null)
            return;

        Vector3Int targetChunkPosition = VoxelUtil.WorldToChunk(target.position, chunkSize);

        //print("TARGET POS: " + target.position + " TARGET LOCALPOS: " + target.localPosition + " CHUNK POS: " + targetChunkPosition);

        if (currentTargetChunkPosition.Equals(targetChunkPosition))
            return;

        // Player changed chunks! Generate new chunks and save old chunks!
        GenerateNearbyChunks(targetChunkPosition);
        SaveFarawayChunks(targetChunkPosition);
    }

    void LateUpdate()
    {
        ProcessGenerateChunkQueue();
        ProcessSaveChunkQueue();
    }

    void GenerateNearbyChunks(Vector3Int targetChunkPosition)
    {
        
        // If there are still chunks to generate, check if they are worth keeping.
        foreach (ChunkNode chunkNode in generateChunkQueue)
        {
            Vector3Int deltaPosition = targetChunkPosition - chunkNode.chunkPosition;
            if (chunkSpawnSize.x < Mathf.Abs(deltaPosition.x) || chunkSpawnSize.y < Mathf.Abs(deltaPosition.y) || chunkSpawnSize.x < Mathf.Abs(deltaPosition.z))
            {
                generateChunkQueue.Remove(chunkNode);
                continue;
            }
            
            generateChunkQueue.UpdatePriority(chunkNode, (targetChunkPosition - chunkNode.chunkPosition).sqrMagnitude); // Near player = Higher priority
        }

        // Queue every chunk under the new radius to generate
        for (int x = targetChunkPosition.x - chunkSpawnSize.x; x <= targetChunkPosition.x + chunkSpawnSize.x; x++)
        {
            for (int z = targetChunkPosition.z - chunkSpawnSize.x; z <= targetChunkPosition.z + chunkSpawnSize.x; z++)
            {
                for (int y = targetChunkPosition.y - chunkSpawnSize.y; y <= targetChunkPosition.y + chunkSpawnSize.y; y++) 
                {
                    Vector3Int chunkPosition = new Vector3Int(x, y, z);
                    ChunkNode chunkNode = new ChunkNode { chunkPosition = chunkPosition };

                    // Tries to get chunk from dict
                    if (chunks.ContainsKey(chunkPosition))
                    {
                        // Chunk is on dict! It should not be destroyed.
                        if (saveChunkQueue.Contains(chunkNode))
                            saveChunkQueue.Remove(chunkNode);

                        continue;
                    }

                    // If chunk is already on queue, it's inside SpawnSize and the priority was already updated
                    if (generateChunkQueue.Contains(chunkNode))
                        continue;

                    generateChunkQueue.Enqueue(chunkNode, (targetChunkPosition - chunkPosition).sqrMagnitude);
                }
            }
        }

        currentTargetChunkPosition = targetChunkPosition;
    }

    void ProcessGenerateChunkQueue()
    {
        int generatedChunks = 0;
        while (generateChunkQueue.Count != 0)
        {
            if (generatedChunks >= maxGenerateChunksInFrame)
                return;

            Vector3Int chunkPosition = generateChunkQueue.Dequeue().chunkPosition;
            GenerateChunk(chunkPosition);
            generatedChunks++;
        }
        if(!initialized)
        {
            initialized = true;
            OnInitializeTerrain?.Invoke();
        }
    }

    Chunk GenerateChunk(Vector3Int chunkPosition)
    {
        // Creates and initializes chunk, if it doesn't exists already
        if (chunks.ContainsKey(chunkPosition))
            return chunks[chunkPosition];

        GameObject chunkGameObject = new GameObject(chunkPosition.ToString());
        chunkGameObject.transform.SetParent(transform);
        chunkGameObject.transform.position = VoxelUtil.ChunkToWorld(chunkPosition, chunkSize);

        Chunk newChunk = chunkGameObject.AddComponent<Chunk>();

        chunks.Add(chunkPosition, newChunk);
        newChunk.Init(chunkPosition, this);

        // If all neighbours are initialized, the chunk can render (update).
        // Makes chunks on the edge of the world wait.
        // Chunk needs who are neighbouring voxels before it can render!
        //newChunk.CanUpdate += delegate
        //{
        //    for (int x = chunkPosition.x - 1; x <= chunkPosition.x + 1; x++)
        //    {
        //        for (int z = chunkPosition.z - 1; z <= chunkPosition.z + 1; z++)
        //        {
        //            for (int y = chunkPosition.y - 1; y <= chunkPosition.y + 1; y++)
        //            {
        //                Vector3Int neighborChunkPosition = new Vector3Int(x, y, z);
        //                if (chunks.TryGetValue(neighborChunkPosition, out Chunk neighborChunk))
        //                {
        //                    if (!neighborChunk.Initialized)
        //                    {
        //                        return false;
        //                    }
        //                }
        //                else
        //                {
        //                    return false;
        //                }
        //            }
        //        }
        //    }
        //    return true;
        //};

        return newChunk;
    }

    public bool GetChunk(Vector3 worldPosition, out Chunk chunk)
    {
        Vector3Int chunkPosition = VoxelUtil.WorldToChunk(worldPosition, chunkSize);
        return chunks.TryGetValue(chunkPosition, out chunk);
    }

    public bool GetVoxel(Vector3 worldPosition, out Voxel voxel)
    {
        if (GetChunk(worldPosition, out Chunk chunk))
        {
            Vector3Int chunkPosition = VoxelUtil.WorldToChunk(worldPosition, chunkSize);
            Vector3Int gridPosition = VoxelUtil.WorldToGrid(worldPosition, chunkPosition, chunkSize);
            if(chunk.GetVoxel(gridPosition, out voxel))
                return true;
        }
        
        voxel = VoxelUtil.Empty;
        return false;
    }

    // TO DO: Check for colliders before allowing voxel to be set
    public bool SetVoxel(Vector3 worldPosition, Voxel type)
    {
        if (GetChunk(worldPosition, out Chunk chunk))
        {
            // Get positions for voxel and chunk containing voxel
            Vector3Int chunkPosition = VoxelUtil.WorldToChunk(worldPosition, chunkSize);
            Vector3Int gridPosition = VoxelUtil.WorldToGrid(worldPosition, chunkPosition, chunkSize);
            if (chunk.SetVoxel(gridPosition, type))
            {
                // Check if neighbour voxels are in other chunks 
                for (int x = -1; x <= 1; x++)
                {
                    for (int y = -1; y <= 1; y++)
                    {
                        for (int z = -1; z <= 1; z++)
                        {
                            if (VoxelUtil.BoundaryCheck(gridPosition + new Vector3Int(x, y, z), chunkSize))
                                continue;

                            Vector3Int neighborChunkPosition = VoxelUtil.WorldToChunk(worldPosition + new Vector3(x, y, z), chunkSize);
                            if (chunkPosition == neighborChunkPosition)
                                continue;
                            
                            if (chunks.TryGetValue(neighborChunkPosition, out Chunk neighborChunk))
                            {
                                neighborChunk.NeighborChunkIsChanged();
                            }
                        }
                    }
                }

                return true;
            }
        }
        return false;
    }

    // This is shit
    public bool SetVoxelVolume(Vector3 worldPosition, Voxel type, Vector3Int volume, bool overwriteSolid = true)
    {

        Vector3 fixedHalfVolume = ( (Vector3) volume / 2.0f) - (0.5f * Vector3.one);

        Vector3[] allVoxelPos = new Vector3[volume.x * volume.y * volume.z];
        Vector3 voxelPos;
        int i = 0;

        for (float x = -fixedHalfVolume.x; x <= fixedHalfVolume.x; x++)
        {
            for (float y = -fixedHalfVolume.y; y <= fixedHalfVolume.y; y++)
            {
                for (float z = -fixedHalfVolume.z; z <= fixedHalfVolume.z; z++)
                {
                    voxelPos = worldPosition + new Vector3(x, y, z);
                    print("ObjPos" + i + " = " + voxelPos);
                    allVoxelPos[i++] = voxelPos;
                    if (!overwriteSolid) {
                        GetVoxel(voxelPos, out Voxel voxel);
                        if (voxel != VoxelUtil.Empty)
                            return false;
                    }
                }
            }
        }

        for(int x = 0; x < allVoxelPos.Length; x++)
        {
            SetVoxel(allVoxelPos[x], type);
        }

        return true;
    }

    public List<Voxel[]> GetNeighborVoxels(Vector3Int chunkPosition, int numNeighbor)
    {
        List<Voxel[]> neighborVoxels = new List<Voxel[]>();
        
        for (int x = chunkPosition.x - numNeighbor; x <= chunkPosition.x + numNeighbor; x++)
        {
            for (int y = chunkPosition.y - numNeighbor; y <= chunkPosition.y + numNeighbor; y++)
            {
                for (int z = chunkPosition.z - numNeighbor; z <= chunkPosition.z + numNeighbor; z++)
                {
                    Vector3Int neighborChunkPosition = new Vector3Int(x, y, z);
                    if (chunks.TryGetValue(neighborChunkPosition, out Chunk chunk))
                    {
                        neighborVoxels.Add(chunk.Voxels);
                    }
                    else
                    {
                        neighborVoxels.Add(null);
                    }
                }
            }
        }

        return neighborVoxels;
    }

    // Marks chunk player is currently at
    private void OnDrawGizmos()
    {
        Gizmos.color = Color.blue;
        Vector3 pos = VoxelUtil.ChunkToWorld(currentTargetChunkPosition, chunkSize);
        Gizmos.DrawWireCube(pos + new Vector3(chunkSize.x / 2f, chunkSize.y / 2f, chunkSize.z / 2f), chunkSize);
    }
}

---
Script: CameraController.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\CameraController.cs)

using UnityEngine;

public class CameraController : MonoBehaviour
{
    [SerializeField] Transform target;
    [SerializeField] float sensitivity = 5.0f;
    [SerializeField] float height = 2.0f;

    Transform cameraTransform;
    Vector2 mouseLook;
    Vector2 input;

    void Awake()
    {
        cameraTransform = transform;
    }

    void Start()
    {
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;
    }

    void LateUpdate()
    {
        if (!GameController.IsPaused)
        {
            input = new Vector2(Input.GetAxisRaw("Mouse X"), Input.GetAxisRaw("Mouse Y"));
            input *= sensitivity;

            mouseLook += input;
            mouseLook.y = Mathf.Clamp(mouseLook.y, -90f, 90f);

            Quaternion targetRotation = Quaternion.AngleAxis(mouseLook.x, target.transform.up);
            Quaternion cameraRotation = targetRotation * Quaternion.AngleAxis(-mouseLook.y, Vector3.right);

            target.rotation = targetRotation;
            cameraTransform.position = target.transform.position + Vector3.up * height;
            cameraTransform.rotation = cameraRotation;
        }
    }
}
---
Script: PlayerBumper.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerBumper.cs)

﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PlayerBumper : MonoBehaviour
{
    public float pushForceHorizontal = 2f;
    public float pushForceLift = .5f;

    private void OnTriggerStay(Collider other)
    {
        Rigidbody rb = other.GetComponent<Rigidbody>();
        if (rb != null)
        {
            Vector3 force = other.transform.position - transform.position;
            force.y = 0f;
            force.Normalize();
            force *= pushForceHorizontal;
            force.y = pushForceLift;
            rb.AddForce(force, ForceMode.VelocityChange);
        }
    }

    protected virtual void OnTriggerEnter(Collider other)
    {
        // Possibility: Enemies grabbing items (for that, should implement enemy bumper).
        //IInteractable itr = other.GetComponent<WorldItem>();
        //if (itr.Method == InteractionMethod.ByBump)
        //{
        //        itr.Interact();
        //}
    }
}

---
Script: PlayerController.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerController.cs)

﻿using UnityEngine;

// FPSWalkerEnhanced
// From Unify Community Wiki

// https://wiki.unity3d.com/index.php/FPSWalkerEnhanced#FPSWalkerEnhanced.cs

[RequireComponent(typeof(CharacterController))]
public class PlayerController : MonoBehaviour
{
    [Tooltip("How fast the player moves when walking (default move speed).")]
    [SerializeField]
    private float m_WalkSpeed = 6.0f;

    [Tooltip("How fast the player moves when running.")]
    [SerializeField]
    private float m_RunSpeed = 11.0f;

    [Tooltip("If true, diagonal speed (when strafing + moving forward or back) can't exceed normal move speed; otherwise it's about 1.4 times faster.")]
    [SerializeField]
    public bool m_LimitDiagonalSpeed = true;

    [Tooltip("If checked, the run key toggles between running and walking. Otherwise player runs if the key is held down.")]
    [SerializeField]
    private bool m_ToggleRun = false;

    [Tooltip("How high the player jumps when hitting the jump button.")]
    [SerializeField]
    private float m_JumpSpeed = 8.0f;

    [Tooltip("How fast the player falls when not standing on anything.")]
    [SerializeField]
    private float m_Gravity = 20.0f;

    [Tooltip("Units that player can fall before a falling function is run. To disable, type \"infinity\" in the inspector.")]
    [SerializeField]
    private float m_FallingThreshold = 10.0f;

    [Tooltip("If the player ends up on a slope which is at least the Slope Limit as set on the character controller, then he will slide down.")]
    [SerializeField]
    private bool m_SlideWhenOverSlopeLimit = false;

    [Tooltip("If checked and the player is on an object tagged \"Slide\", he will slide down it regardless of the slope limit.")]
    [SerializeField]
    private bool m_SlideOnTaggedObjects = false;

    [Tooltip("How fast the player slides when on slopes as defined above.")]
    [SerializeField]
    private float m_SlideSpeed = 12.0f;

    [Tooltip("If checked, then the player can change direction while in the air.")]
    [SerializeField]
    private bool m_AirControl = false;

    [Tooltip("Small amounts of this results in bumping when walking down slopes, but large amounts results in falling too fast.")]
    [SerializeField]
    private float m_AntiBumpFactor = .75f;

    [Tooltip("Player must be grounded for at least this many physics frames before being able to jump again; set to 0 to allow bunny hopping.")]
    [SerializeField]
    private int m_AntiBunnyHopFactor = 1;

    //[Tooltip("How hard does objects move horizontally when pushed around by player")]
    //[SerializeField]
    //private float m_PushForceHorizontal = 1f;

    //[Tooltip("How hard does objects lift, when pushed around by player")]
    //[SerializeField]
    //private float m_PushForceLift = 1f;

    private Vector3 m_MoveDirection = Vector3.zero;
    private bool m_Grounded = false;
    private CharacterController m_Controller;
    [HideInInspector] public Transform m_Transform;
    private float m_Speed;
    private RaycastHit m_Hit;
    private float m_FallStartLevel;
    private bool m_Falling;
    private float m_SlideLimit;
    private float m_RayDistance;
    private Vector3 m_ContactPoint;
    private bool m_PlayerControl = false;
    private int m_JumpTimer;


    private void Awake()
    {
        // Saving component references to improve performance.
        m_Transform = GetComponent<Transform>();
        m_Controller = GetComponent<CharacterController>();

        // Setting initial values.
        m_Speed = m_WalkSpeed;
        m_RayDistance = m_Controller.height * .5f + m_Controller.radius;
        m_SlideLimit = m_Controller.slopeLimit - .1f;
        m_JumpTimer = m_AntiBunnyHopFactor;
    }


    private void Update()
    {
        // If the run button is set to toggle, then switch between walk/run speed. (We use Update for this...
        // FixedUpdate is a poor place to use GetButtonDown, since it doesn't necessarily run every frame and can miss the event)

        float inputX = Input.GetAxis("Horizontal");
        float inputY = Input.GetAxis("Vertical");

        if (m_ToggleRun && m_Grounded && Input.GetButtonDown("Run"))
        {
            m_Speed = (m_Speed == m_WalkSpeed ? m_RunSpeed : m_WalkSpeed);
        }

        // If both horizontal and vertical are used simultaneously, limit speed (if allowed), so the total doesn't exceed normal move speed
        float inputModifyFactor = (inputX != 0.0f && inputY != 0.0f && m_LimitDiagonalSpeed) ? .7071f : 1.0f;

        if (m_Grounded)
        {
            bool sliding = false;
            // See if surface immediately below should be slid down. We use this normally rather than a ControllerColliderHit point,
            // because that interferes with step climbing amongst other annoyances
            if (Physics.Raycast(m_Transform.position, -Vector3.up, out m_Hit, m_RayDistance))
            {
                if (Vector3.Angle(m_Hit.normal, Vector3.up) > m_SlideLimit)
                {
                    sliding = true;
                }
            }
            // However, just raycasting straight down from the center can fail when on steep slopes
            // So if the above raycast didn't catch anything, raycast down from the stored ControllerColliderHit point instead
            else
            {
                Physics.Raycast(m_ContactPoint + Vector3.up, -Vector3.up, out m_Hit);
                if (Vector3.Angle(m_Hit.normal, Vector3.up) > m_SlideLimit)
                {
                    sliding = true;
                }
            }

            // If we were falling, and we fell a vertical distance greater than the threshold, run a falling damage routine
            if (m_Falling)
            {
                m_Falling = false;
                if (m_Transform.position.y < m_FallStartLevel - m_FallingThreshold)
                {
                    OnFell(m_FallStartLevel - m_Transform.position.y);
                }
            }

            // If running isn't on a toggle, then use the appropriate speed depending on whether the run button is down
            if (!m_ToggleRun)
            {
                m_Speed = Input.GetKey(KeyCode.LeftShift) ? m_RunSpeed : m_WalkSpeed;
            }

            // If sliding (and it's allowed), or if we're on an object tagged "Slide", get a vector pointing down the slope we're on
            if ((sliding && m_SlideWhenOverSlopeLimit) || (m_SlideOnTaggedObjects && m_Hit.collider.tag == "Slide"))
            {
                Vector3 hitNormal = m_Hit.normal;
                m_MoveDirection = new Vector3(hitNormal.x, -hitNormal.y, hitNormal.z);
                Vector3.OrthoNormalize(ref hitNormal, ref m_MoveDirection);
                m_MoveDirection *= m_SlideSpeed;
                m_PlayerControl = false;
            }
            // Otherwise recalculate moveDirection directly from axes, adding a bit of -y to avoid bumping down inclines
            else
            {
                m_MoveDirection = new Vector3(inputX * inputModifyFactor, -m_AntiBumpFactor, inputY * inputModifyFactor);
                m_MoveDirection = m_Transform.TransformDirection(m_MoveDirection) * m_Speed;
                m_PlayerControl = true;
            }

            // Jump! But only if the jump button has been released and player has been grounded for a given number of frames
            if (!Input.GetButton("Jump"))
            {
                m_JumpTimer++;
            }
            else if (m_JumpTimer >= m_AntiBunnyHopFactor)
            {
                m_MoveDirection.y = m_JumpSpeed;
                m_JumpTimer = 0;
            }
        }
        else
        {
            // If we stepped over a cliff or something, set the height at which we started falling
            if (!m_Falling)
            {
                m_Falling = true;
                m_FallStartLevel = m_Transform.position.y;
            }

            // If air control is allowed, check movement but don't touch the y component
            if (m_AirControl && m_PlayerControl)
            {
                m_MoveDirection.x = inputX * m_Speed * inputModifyFactor;
                m_MoveDirection.z = inputY * m_Speed * inputModifyFactor;
                m_MoveDirection = m_Transform.TransformDirection(m_MoveDirection);
            }
        }

        // Apply gravity
        m_MoveDirection.y -= m_Gravity * Time.deltaTime;

        // Move the controller, and set grounded true or false depending on whether we're standing on something
        m_Grounded = (m_Controller.Move(m_MoveDirection * Time.deltaTime) & CollisionFlags.Below) != 0;
    }


    // Store point that we're in contact with for use in FixedUpdate if needed
    private void OnControllerColliderHit(ControllerColliderHit hit)
    {
        //if (hit.gameObject.layer == Consts.interactableLayer)
        //{
        //    print("hit");
        //    Rigidbody rb = hit.gameObject.GetComponent<Rigidbody>();
        //    if (rb != null)
        //    {
        //        Vector3 force = hit.point - transform.position;
        //        force.y = 0f;
        //        force.Normalize();
        //        force *= m_PushForceHorizontal;
        //        force.y = m_PushForceLift;
        //        rb.AddForce(force, ForceMode.VelocityChange);
        //    }
        //}
        m_ContactPoint = hit.point;
    }


    // This is the place to apply things like fall damage. You can give the player hitpoints and remove some
    // of them based on the distance fallen, play sound effects, etc.
    private void OnFell(float fallDistance)
    {
        print("Ouch! Fell " + fallDistance + " units!");
    }

    #region Serialization

    public WorldPlacementData GetData()
    {
        return new WorldPlacementData(m_Transform);
    }

    public void SetData(WorldPlacementData data)
    {
        print("POS " + data.position[0] + " " + data.position[1] + " " + data.position[2]);
        m_Transform.position = new Vector3(data.position[0], data.position[1], data.position[2]);
        m_Transform.rotation = Quaternion.Euler(data.rotation[0], data.rotation[1], data.rotation[2]);
        m_Transform.localScale = new Vector3(data.scale[0], data.scale[1], data.scale[2]);
    }

    #endregion
}
---
Script: PlayerManager.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerManager.cs)

﻿using UnityEngine;
using System.Collections;
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;

public class PlayerManager : Singleton<PlayerManager>
{
    public PlayerController playerController;

    public PlayerStats playerStats;

    public Inventory playerInventory;

    #region Serialization

    private void Awake()
    {
        TryLoad();
    }

    public void Save()
    {
        string path = SaveUtil.GetPlayerDataPath();

        BinaryFormatter formatter = new BinaryFormatter();
        FileStream stream = new FileStream(path, FileMode.Create);
        formatter.Serialize(stream, GetData());
        stream.Close();
    }

    public bool TryLoad()
    {
        string path = SaveUtil.GetPlayerDataPath();

        if (!File.Exists(path))
            return false;

        BinaryFormatter formatter = new BinaryFormatter();
        FileStream stream = new FileStream(path, FileMode.Open);
        PlayerData data = formatter.Deserialize(stream) as PlayerData;
        SetData(data);

        return true;
    }

    public PlayerData GetData()
    {
        return new PlayerData(this);
    }

    public void SetData(PlayerData playerData)
    {
        playerController.SetData(playerData.playerPlacementData);

        playerStats.SetData(playerData.playerStatsData);

        playerInventory.SetData(playerData.playerInventoryData);
    }
}

[Serializable]
public class PlayerData
{
    public WorldPlacementData playerPlacementData;
    public PlayerStatsData playerStatsData;
    public ItemContainerData playerInventoryData;

    public PlayerData(PlayerManager playerManager)
    {
        playerPlacementData = playerManager.playerController.GetData();
        playerStatsData = playerManager.playerStats.GetData();
        playerInventoryData = playerManager.playerInventory.GetData();
    }
}

#endregion

---
Script: PlayerStats.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerStats.cs)

﻿using UnityEngine;
using System.Collections;
using System;

public delegate void StatModifiedHandle();

public class PlayerStats : Singleton<PlayerStats>
{

    public float Health { get => health; set { health = Mathf.Clamp(value, 0f, maxHealth); OnHealthModified?.Invoke(); } }
    [SerializeField] public float maxHealth;
    [SerializeField] float health;
    public event StatModifiedHandle OnHealthModified;

    public float Mana { get => mana; set => mana = Mathf.Clamp(value, 0f, maxMana); }
    [SerializeField] public float maxMana;
    [SerializeField] float mana;


    public float Stamina { get => stamina; set => stamina = Mathf.Clamp(value, 0f, maxStamina); }
    [SerializeField] public float maxStamina;
    [SerializeField] float stamina;



    [field: SerializeField] public int Strength { get; set; }
    [field: SerializeField] public int Dexterity { get; set; }
    [field: SerializeField] public int Intelligence { get; set; }

    [field: SerializeField] public int Armor { get; set; }

    public int MeleeDamage { get => BaseMeleeDamage + MeleeBonus; }
    [SerializePropertyReadOnly("MeleeDamage")] public int BaseMeleeDamage;
    public int RangedDamage { get => BaseRangedDamage + RangedBonus; }
    [SerializePropertyReadOnly("RangedDamage")] public int BaseRangedDamage;
    public float CriticalChance { get => BaseCriticalChance + CriticalBonus; }
    [SerializePropertyReadOnly("CriticalChance")] public float BaseCriticalChance;

    public int MeleeBonus { get => Mathf.RoundToInt(Strength * 2.5f); }
    public int RangedBonus { get => Mathf.RoundToInt(Dexterity * 2.5f); }
    public float CriticalBonus { get => Intelligence * .4f; }

    public void Modify(Action operation)
    {
        operation();
    }

    public void ModifyTemporarily(Action doOperation, Action undoOperation, int duration)
    {
        doOperation();
        StartCoroutine(ExecuteOperation(undoOperation, duration));
    }

    private IEnumerator ExecuteOperation(Action operation, int delay = 0)
    {
        yield return new WaitForSeconds(delay);
        operation();
    }

    // Use it like: ModifyPerInterval(() => stat += amount, interval, duration);
    public void ModifyPerInterval(Action operation, int interval, int duration)
    {
        if (duration <= 0 || interval <= 0 || duration < interval) throw new Exception("Wrong values for duration or interval");
        StartCoroutine(ModifyPerIntervalRoutine(operation, interval, duration));
    }

    IEnumerator ModifyPerIntervalRoutine(Action operation, int interval, int duration)
    {
        for (int i = 0; i <= duration; i += interval)
        {
            operation();
            yield return new WaitForSeconds(interval);
        }
    }

    public override string ToString()
    {
        return string.Concat(
            "Strength: ", Strength,
            "\nDexterity: ", Dexterity,
            "\nIntelligence: ", Intelligence,
            "\nArmor: ", Armor);
    }

    // Test if stats based on others are correct after load!!!!!!

    #region Serialization

    public PlayerStatsData GetData()
    {
        return new PlayerStatsData(this);
    }

    public void SetData(PlayerStatsData playerStatsData)
    {
        Health = playerStatsData.health;
        Mana = playerStatsData.mana;
        Stamina = playerStatsData.stamina;
        maxHealth = playerStatsData.maxHealth;
        maxMana = playerStatsData.maxMana;
        maxStamina = playerStatsData.maxStamina;

        Strength = playerStatsData.strength;
        Dexterity = playerStatsData.dexterity;
        Intelligence = playerStatsData.intelligence;

        BaseMeleeDamage = playerStatsData.baseMeleeDamage;
        BaseRangedDamage = playerStatsData.baseRangedDamage;
        BaseCriticalChance = playerStatsData.baseCriticalChance;
    }
}

[Serializable]
public class PlayerStatsData
{
    public float health, mana, stamina,
        maxHealth, maxMana, maxStamina;

    public int strength, dexterity, intelligence;

    public int baseMeleeDamage;
    public int baseRangedDamage;
    public float baseCriticalChance;

    public PlayerStatsData(PlayerStats playerStats)
    {
        health = playerStats.Health;
        mana = playerStats.Mana;
        stamina = playerStats.Stamina;
        maxHealth = playerStats.maxHealth;
        maxMana = playerStats.maxMana;
        maxStamina = playerStats.maxStamina;

        strength = playerStats.Strength;
        dexterity = playerStats.Dexterity;
        intelligence = playerStats.Intelligence;

        baseMeleeDamage = playerStats.BaseMeleeDamage;
        baseRangedDamage = playerStats.BaseRangedDamage;
        baseCriticalChance = playerStats.BaseCriticalChance;
    }
}

#endregion
---
Script: SceneStarter.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\SceneStarter.cs)

﻿using UnityEngine;
using System.Collections;
using System.IO;

public class SceneStarter : Singleton<SceneStarter>
{

    public GameObject playerCharacter;
    public GameObject mainCamera;

    private void Awake()
    {
        string autosavePath = SaveUtil.GetAutosavePath();
        Directory.CreateDirectory(autosavePath);
    }

    // Use this for initialization
    void Start()
    {
        playerCharacter.SetActive(false);
        //camera.SetActive(false);
        TerrainManager.Main.OnInitializeTerrain += SetScene;
    }

    public void SetScene()
    {
        //camera.SetActive(true);
        playerCharacter.SetActive(true);
    }
}

---
Script: VoxelPlacer.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\VoxelPlacer.cs)

using UnityEngine;

public class VoxelPlacer : MonoBehaviour
{
    public GameObject blockSelection;

    public bool highlightVoxel = false;

    public bool canPlace = true;

    public bool canGrab = true;

    void Update()
    {
        // Place selector on voxel player is currently looking
        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        if (Physics.Raycast(ray, out RaycastHit hit, Consts.InteractionDistance, Consts.VoxelMask))
        {
            if (highlightVoxel && blockSelection)
            {
                PlacementData posRot = ItemUtil.Snap(ray.direction, hit.point + ray.direction * 0.01f, Vector3Int.one, ItemPivot.MidCenter, SnapType.Center);
                blockSelection.transform.position = posRot.position;
                blockSelection.SetActive(true);
            }

            // Set voxel if necessary
            if (!GameController.IsPaused)
            {
                if (Input.GetMouseButtonDown(0) && canPlace)
                {
                    TerrainManager.Main.SetVoxel(hit.point - ray.direction * 0.01f, Voxel.Stone);
                }

                if (Input.GetMouseButtonDown(1) && canGrab)
                {
                    Voxel voxel;
                    TerrainManager.Main.GetVoxel(hit.point + ray.direction * 0.01f, out voxel);
                    if (voxel != Voxel.Air)
                    {
                        TerrainManager.Main.SetVoxel(hit.point + ray.direction * 0.01f, Voxel.Air);
                        ItemStack itemStack = new ItemStack(ItemDatabase.Main.GetCopy(voxel.ToString()));
                        ContainerManager.Main.TryAlterContainer(itemStack);
                    }
                }
            }
        }
        else
        {
            blockSelection?.SetActive(false);
        }
    }
}
---
Script: IInteractable.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\IInteractable.cs)

﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public enum InteractionMethod : byte { ByKey, ByMenu, ByBreak, ByBump };

public interface IInteractable
{
    InteractionMethod Method { get; }

    void Interact();
}

---
Script: InteractionManager.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\InteractionManager.cs)

﻿using UnityEngine;
using System.Collections;

public class InteractionManager : Singleton<InteractionManager>
{
    WorldObject currentWorldObject;

    [SerializeField] GameObject itemGiverPanel;
    [SerializeField] GameObject itemInteractionPanel;

    // Item Specific Menus
    // SomeItemMenu

    private void Start()
    {
        Hide();
    }

    public void Hide()
    {
        // Hide all Panels
        itemGiverPanel.SetActive(false);
        itemInteractionPanel.SetActive(false);
        GameController.IsPaused = false;
    }
}

---
Script: PlayerInteraction.cs (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\PlayerInteraction.cs)

﻿using UnityEngine;
using System.Collections;

public class PlayerInteraction : MonoBehaviour
{
    private Camera cam;
    private ItemContainer inventory;
    private System.Random random = new System.Random();

    private void Start()
    {
        cam = Camera.main;
        inventory = GetComponent<ItemContainer>();
    }
    private void Update()
    {
        if (Input.GetKeyDown(KeyCode.E))
        {
            Interact();
        }
    }

    public bool Interact()
    {
        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Consts.InteractionDistance, Consts.InteractableMask))
        {
            WorldObject worldItem = hit.collider.GetComponent<WorldObject>();
            worldItem.Interact();
        }
        return false;
    }
}

---
Script: ItemDatabase.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemDatabase.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;

public class ItemDatabase : Singleton<ItemDatabase>
{

    Dictionary<string, Item> itemDatabase = new Dictionary<string, Item>();

    public Item[] items;

    public void Awake()
    {
        //Item[] items = (Item[]) Resources.FindObjectsOfTypeAll(typeof(Item));

        foreach (Item i in items)
        {
            itemDatabase.Add(i.name, i);
            print("Item added to database: " + i.name);
        }
    }

    public Item GetCopy(string itemName)
    {
        return itemDatabase[itemName].GetCopy();
    }

    public GameObject GetPrefab(string itemName)
    {
        return itemDatabase[itemName].prefab;
    }
}

---
Script: ItemStack.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemStack.cs)

﻿using UnityEngine;
using System.Collections;

[System.Serializable]
public class ItemStack
{
    public Item item;
    public int amount;

    public ItemStack(Item item, int amount = 1)
    {
        this.item = item;
        this.amount = amount;
    }

    public ItemStack(ItemStackData data)
    {
        amount = data.amount;
        item = ItemDatabase.Main.GetCopy(data.itemData.itemName);
        item.SetData(data.itemData);
    }
}

[System.Serializable]
public class ItemStackData
{
    public ItemData itemData;

    public int amount;

    public ItemStackData(ItemStack itemStack)
    {
        this.itemData = itemStack.item.GetData();
        this.amount = itemStack.amount;
    }
}
---
Script: ItemUtil.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemUtil.cs)

﻿using UnityEngine;
using System.Collections;

public class PlacementData
{
    public Vector3 position = Vector3.zero;
    public Quaternion rotation = Quaternion.identity;
    public Vector3 volumeCenter = Vector3.zero;
}

public static class ItemUtil
{

    public static readonly Vector3 Corner2TopMid = Vector3.up + Vector3.right * .5f + Vector3.forward * .5f;

    public static readonly Vector3 CollisionAllowance = new Vector3(.001f, .001f, .001f);

    // Snaps to center, edge or corner of a square
    public static PlacementData Snap(Vector3 rayDir, Vector3 worldPosition, Vector3 volume, ItemPivot itemPivot, SnapType snapType) // OK!
    {
        PlacementData placementData = new PlacementData();

        switch (snapType)
        {
            case SnapType.Center:
                placementData.position.x = Mathf.Floor(worldPosition.x) + .5f;
                placementData.position.z = Mathf.Floor(worldPosition.z) + .5f;

                break;

            case SnapType.Edge:
                placementData.position.x = Mathf.Round(worldPosition.x);
                placementData.position.z = Mathf.Round(worldPosition.z);

                float deltaX = worldPosition.x - placementData.position.x;
                float deltaZ = worldPosition.z - placementData.position.z;

                if (Mathf.Abs(deltaX) >= Mathf.Abs(deltaZ))
                {
                    placementData.position += Vector3.right * .5f * Mathf.Sign(deltaX);
                    //posRot.rotation = Quaternion.Euler(0f, 90f, 0f);
                }
                else
                {
                    placementData.position += Vector3.forward * .5f * Mathf.Sign(deltaZ);
                }
                break;

            case SnapType.Corner:
                placementData.position.x = Mathf.Round(worldPosition.x);
                placementData.position.z = Mathf.Round(worldPosition.z);
                break;
        }

        // VolumeCenter X and Z coordinates are the same as Position
        placementData.volumeCenter = placementData.position;

        float posY = 0f, volY = 0f;

        switch (itemPivot)
        {
            case ItemPivot.Bottom:
                posY = Mathf.Floor(worldPosition.y); // Should be lowest point of object
                volY = posY + (volume.y / 2f);
                break;
            case ItemPivot.MidCenter:
                posY = Mathf.Floor(worldPosition.y) + .5f; // Should be middle of object (snap to center)
                volY = posY;
                break;
            case ItemPivot.MidCorner:
                placementData.position.y = Mathf.Round(worldPosition.y); // Should be middle of object (snap to corner)
                volY = posY;
                break;
            case ItemPivot.Top:
                placementData.position.y = Mathf.Ceil(worldPosition.y); // Should be highest point of object
                volY = posY - (volume.y / 2f);
                break;
        }

        placementData.position.y = posY;
        placementData.volumeCenter.y = volY;

        float angle = 0f;
        if (!rayDir.Equals(Vector3.zero))
        {
            angle = Mathf.Atan2(rayDir.x, rayDir.z) * Mathf.Rad2Deg; // Z & X or X & Z?
            angle = Mathf.Round(angle / 90f) * 90f;
        }
        else
        {
            angle = GetRandomRot();
        }

        placementData.rotation = Quaternion.Euler(0f, angle, 0f);
        return placementData;
    }

    public static float GetRandomRot()
    {
        int a = UnityEngine.Random.Range(0, 4);
        switch (a)
        {
            case 0:
                return 0f;
            case 1:
                return 90f;
            case 2:
                return 180f;
            case 3:
                return 270f;
        }
        return 0f;
    }

    public static Vector3 FindNearestEmpty(Vector3 position)
    {
        throw new System.NotImplementedException();
    }
}
---
Script: SpawnManager.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\SpawnManager.cs)

﻿using UnityEngine;
using System.Collections.Generic;
using Priority_Queue;
using Unity.Mathematics;
using System.Collections;

public class SpawnManager : Singleton<SpawnManager>
{
    new Transform transform;

    private void Awake()
    {
        transform = GetComponent<Transform>();
    }

    public bool TryPopulate(Vector3 rayDir, Vector3 worldPosition, ItemStack itemStack)
    {
        PlacementData placementData = new PlacementData();

        placementData = ItemUtil.Snap(rayDir, worldPosition, itemStack.item.volume, itemStack.item.pivot, itemStack.item.snapType);

        // Check if it's solid here?
        bool canPlace = itemStack.item.ValidatePopulation(placementData.volumeCenter);
        if (canPlace)
        {
            GameObject g = Instantiate(itemStack.item.prefab, transform);
            WorldObject wi = g.GetComponent<WorldObject>();
            wi.Initialize(placementData.position, placementData.rotation, itemStack.item.prefab.transform.localScale, itemStack);
            TerrainManager.Main.AddItem(worldPosition, wi);

            return true;
        }
        return false;
    }

    public bool TrySpawnItem(Vector3 rayDir, Vector3 worldPosition, string slotID)
    {
        ItemStack itemStack = ContainerManager.Main.PeekSlot(slotID);
        return TrySpawnOneItem(rayDir, worldPosition, itemStack, slotID);
    }

    // MAKE A DROP FUNCTION HERE

    // Raydir = Vector3.zero gets random vector
    public bool TrySpawnOneItem(Vector3 rayDir, Vector3 worldPosition, ItemStack itemStack, string itemSlot)
    {
        PlacementData placementData = new PlacementData();

        placementData = ItemUtil.Snap(rayDir, worldPosition, itemStack.item.volume, itemStack.item.pivot, itemStack.item.snapType);

        // Check if it's solid here?
        bool canPlace = itemStack.item.ValidatePlacement(placementData.volumeCenter);
        if (canPlace)
        {
            GameObject g = Instantiate(itemStack.item.prefab, transform);
            WorldObject wi = g.GetComponent<WorldObject>();
            ItemStack newItemStack = new ItemStack(itemStack.item, 1);
            wi.Initialize(placementData.position, placementData.rotation, itemStack.item.prefab.transform.localScale, newItemStack);

            TerrainManager.Main.AddItem(worldPosition, wi);

            return true;
        }
        return false;
    }

    public void SpawnByLoad(WorldObjectData WorldObjectData, out WorldObject WorldObject)
    {
        GameObject prefab = ItemDatabase.Main.GetPrefab(WorldObjectData.itemStackData.itemData.itemName);
        GameObject g = Instantiate(prefab, transform);
        WorldObject wi = g.GetComponent<WorldObject>();
        wi.SetData(WorldObjectData);
        WorldObject = wi;
    }
}

---
Script: ContainerManager.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ContainerManager.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using UnityEngine.UI;
using TMPro;

// Slot handling is a mess, and it starts in this class
// It works but it should really be handled in a better way.
public class ContainerManager : Singleton<ContainerManager>
{
    public Inventory playerInventory;
    ItemStash currentOpenStash;

    public Dictionary<string, ItemSlot> UISlots = new Dictionary<string, ItemSlot>();

    [SerializeField] ItemSlot handSlot;
    string lastSlotID;

    string[] hotbarSlotIDs;
    int selectedHotbarSlotIndex = 0; // Currently selected hotbar slot
    public RectTransform selectionIndicatorUI;

    public GameObject HUDCenter;

    private void Start()
    {
        // Define slots
        List<string> stashSlotIDs = new List<string>();
        List<string> inventorySlotIDs = new List<string>();
        List<string> hotbarSlotIDs = new List<string>();
        ItemSlot[] slots = GetComponentsInChildren<ItemSlot>(true);
        foreach (ItemSlot slot in slots)
        {
            string name = slot.gameObject.name;
            UISlots.Add(name, slot);
            switch (name[0])
            {
                case 'S':
                    stashSlotIDs.Add(name);
                    break;
                case 'H':
                    hotbarSlotIDs.Add(name);
                    inventorySlotIDs.Add(name);
                    break;
                case 'B':
                    inventorySlotIDs.Add(name);
                    break;
                default:
                    break;
            }
        }
        ItemStash.slotIDs = stashSlotIDs.ToArray();
        Inventory.slotIDs = inventorySlotIDs.ToArray();
        this.hotbarSlotIDs = hotbarSlotIDs.ToArray();
        RefreshInventory(); // FreshPrince™
    }

    bool isVisible = false;
    private void Update()
    {
        // TO DO: USE NEW INPUT SYSTEM!!!
        if (Input.GetKeyDown(KeyCode.I))
        {
            if (isVisible)
                Hide();
            else
                Show();
        }
        CheckChangeSelection();
        if (Input.GetKeyDown(KeyCode.Mouse0) && !GameController.IsPaused)
        {
            UseHotbarItem(selectedHotbarSlotIndex);
        }
    }

    public void CheckChangeSelection()
    {
        float wheelInput = Input.GetAxis("Mouse ScrollWheel");
        if (!(wheelInput.Equals(0f)))
        {
            selectedHotbarSlotIndex = (selectedHotbarSlotIndex + (int)Mathf.Sign(wheelInput)) % hotbarSlotIDs.Length;
            if (selectedHotbarSlotIndex < 0) selectedHotbarSlotIndex += hotbarSlotIDs.Length;
            selectionIndicatorUI.anchoredPosition = new Vector3(15f + selectedHotbarSlotIndex * 17f, .25f, 0f);
        }
    }

    public void UseHotbarItem(int slotIndex)
    {
        UseItem(hotbarSlotIDs[slotIndex]);
    }

    public void UseItem(string slotID)
    {
        GetContainerBySlot(slotID).UseItem(slotID);
    }

    public string GetSelectedSlotID()
    {
        return hotbarSlotIDs[selectedHotbarSlotIndex];
    }

    public void OpenStash(ItemStash stash)
    {
        currentOpenStash = stash;
        RefreshStash();
    }

    public bool TryAlterContainer(ItemStack itemStack, char slotGroup = 'H')
    {
        if (slotGroup == 'S')
            return currentOpenStash.TryAlter(itemStack);

        return playerInventory.TryAlter(itemStack);
    }

    public void OverwriteSlot(string slotID, ItemStack item)
    {
        GetContainerBySlot(slotID).OverwriteSlot(slotID, item);
    }

    public ItemStack PeekSlot(string slotID)
    {
        return GetContainerBySlot(slotID).Peek(slotID);
    }

    public void PickSlot(ItemSlot itemSlot, bool rightButton = false)
    {
        ItemStack handStack;
        ItemStack slotStack;

        if (handSlot.itemStack == null || handSlot.itemStack.item == null)
        {
            if (itemSlot.itemStack == null || itemSlot.itemStack.item == null)
                return;

            // Hand is empty and slot has item, must pick item
            handStack = new ItemStack(itemSlot.itemStack.item, 0);
            slotStack = new ItemStack(itemSlot.itemStack.item, 0);

            if (rightButton)
            {
                // Right button was used, pick half if possible
                if (itemSlot.itemStack.amount < 2)
                    return;

                int halfAmount = itemSlot.itemStack.amount / 2;
                handStack.amount = halfAmount;
                slotStack.amount = itemSlot.itemStack.amount - halfAmount;
            }
            else    // Left button was used, pick whole amount into hand
            {
                handStack.amount = itemSlot.itemStack.amount;
            }

            HideTooptip();
        }
        else
        {
            // Hand has item, must drop
            handStack = new ItemStack(itemSlot.itemStack != null ? itemSlot.itemStack.item : null, 0);
            slotStack = new ItemStack(handSlot.itemStack.item, 0);
            bool sameItemType = itemSlot.itemStack != null && itemSlot.itemStack.item == handSlot.itemStack.item;
            int slotAmount = sameItemType ?
                itemSlot.itemStack.amount : 0;

            if (rightButton)
            {
                // Right button was used, so place only one if possible
                if (itemSlot.itemStack != null && (!sameItemType || slotAmount + 1 > itemSlot.itemStack.item.maxStack))
                    return;

                handStack.item = handSlot.itemStack.item;
                slotStack.amount = slotAmount + 1;
                handStack.amount = handSlot.itemStack.amount - 1;
            }
            else
            {
                // Left button was pressed, place as much as possible or switch
                if (sameItemType)
                {
                    int spaceLeft = itemSlot.itemStack.item.maxStack - slotAmount;
                    int addAmount = Mathf.Min(spaceLeft, handSlot.itemStack.amount);
                    slotStack.amount = slotAmount + addAmount;
                    handStack.amount = handSlot.itemStack.amount - addAmount;
                }
                else
                {
                    slotStack.amount = handSlot.itemStack.amount;
                    handStack.amount = itemSlot.itemStack != null ? itemSlot.itemStack.amount : 0;
                }
            }
        }

        OverwriteHandSlot(handStack);
        OverwriteSlot(itemSlot.ID, slotStack);
        lastSlotID = itemSlot.ID;
    }

    public void CancelPickSlot()
    {
        if (handSlot.itemStack != null && handSlot.itemStack.item != null)
        {
            print(handSlot.itemStack.item);
            ItemSlot lastSlot = UISlots[lastSlotID];
            PickSlot(lastSlot);
        }
    }

    public ItemContainer GetContainerBySlot(string slotID)
    {

        // This is kinda arbitrary, think of another way of doing this without manually setting each one
        switch (slotID[0])
        {
            case 'S':
                return currentOpenStash;
            case 'E': // 'E', 'B' or 'H' 
            case 'H':
            case 'B':
                return playerInventory;
            default:
                throw new System.Exception("Slot has unknown container type.");
        }
    }


    #region UI Control Stuff

    public GraphicRaycaster graphicRaycaster;

    [SerializeField] GameObject inventoryPanel;
    [SerializeField] GameObject stashPanel;

    Coroutine dragFollowRoutine, tooltipFollowRoutine;
    [SerializeField] Tooltip tooltip;
    [SerializeField] Vector3 tooltipOffset = new Vector3(1f, -1f, 0);

    public void Show(bool showStash = false)
    {
        HUDCenter.SetActive(false);
        inventoryPanel.SetActive(true);
        if (showStash)
            stashPanel.SetActive(true);
        isVisible = true;
        GameController.IsPaused = true;
    }

    public void Hide()
    {
        HUDCenter.SetActive(true);
        inventoryPanel.SetActive(false);
        stashPanel.SetActive(false);
        HideTooptip();
        CancelPickSlot();
        isVisible = false;
        GameController.IsPaused = false;
    }
    public void RefreshInventory()
    {
        ItemStack item;
        foreach (KeyValuePair<string, ItemSlot> slot in UISlots)
        {
            switch (slot.Key[0])
            {
                case 'S':
                    break;
                default: // 'E' or 'B'
                    item = playerInventory.Peek(slot.Key);
                    if (item != null)
                        slot.Value.SetItemRep(item);
                    else
                        slot.Value.ClearItemRep();
                    break;
            }
        }
    }

    public void RefreshStash()
    {
        foreach (KeyValuePair<string, ItemSlot> slot in UISlots)
        {
            if (slot.Key[0] == 'S')
            {
                ItemStack itemStack = currentOpenStash.Peek(slot.Key);
                if (itemStack != null)
                    slot.Value.SetItemRep(itemStack);
                else
                    slot.Value.ClearItemRep();
            }
        }
    }

    public void UpdateSlotUI(string slotID, ItemStack itemStack)
    {
        if (itemStack != null && itemStack.amount > 0)
            UISlots[slotID].SetItemRep(itemStack);
        else
            UISlots[slotID].ClearItemRep();
    }

    public void OverwriteHandSlot(ItemStack itemStack)
    {
        if (dragFollowRoutine != null)
            StopCoroutine(dragFollowRoutine);

        if (itemStack.item != null && itemStack.amount > 0)
        {
            handSlot.SetItemRep(itemStack);
            dragFollowRoutine = StartCoroutine(ImageFollowCursor(handSlot, Vector3.zero));
            return;
        }
        handSlot.ClearItemRep();
    }

    public void ShowTooltip(ItemSlot itemSlot)
    {
        if (handSlot.itemStack == null)
        {
            tooltip.SetText(itemSlot.itemStack.item.ToString());
            tooltip.gameObject.SetActive(true);
            tooltipFollowRoutine = StartCoroutine(ImageFollowCursor(tooltip, tooltipOffset));
        }
    }

    public void HideTooptip()
    {
        if (tooltipFollowRoutine != null)
            StopCoroutine(tooltipFollowRoutine);
        tooltip.gameObject.SetActive(false);
    }

    IEnumerator ImageFollowCursor(ImageController imageController, Vector3 offset)
    {
        for (; ; )
        {
            imageController.SetPosition(Input.mousePosition + offset);
            yield return null;
        }
    }

    #endregion
}

---
Script: Inventory.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\Inventory.cs)

﻿using UnityEngine;
using System.Collections.Generic;
using System.Linq;

public class Inventory : ItemContainer
{
    public static string[] slotIDs;
    public override string[] SlotIDs { get => slotIDs; }
    public override int Capacity { get => slotIDs.Length - slotIDs.Count(id => id[0] == 'E'); }

    [SerializeField] PlayerStats playerStats;

    public void IncreaseStats(Equipment equipment)
    {
        playerStats.Armor += equipment.armor;
        playerStats.BaseMeleeDamage += equipment.meleeDamage;
        playerStats.BaseRangedDamage += equipment.rangedDamage;

        // TO DO: HANDLE ENCHANTMENT HERE
    }

    public void DecreaseStats(Equipment equipment)
    {
        playerStats.Armor -= equipment.armor;
        playerStats.BaseMeleeDamage -= equipment.meleeDamage;
        playerStats.BaseRangedDamage -= equipment.rangedDamage;

        // TO DO: HANDLE ENCHANTMENT HERE
    }
}

---
Script: ItemContainer.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ItemContainer.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;


public abstract class ItemContainer : MonoBehaviour
{

    public abstract string[] SlotIDs { get; }

    public abstract int Capacity { get; }

    Dictionary<string, ItemStack> containedItems = new Dictionary<string, ItemStack>();

    public int ItemCount { get => containedItems.Count; }

    public int FreeSlotCount { get => Capacity - ItemCount; }

    public void UseItem(string slotID)
    {
        ItemStack itemStack = Peek(slotID);
        if (itemStack != null)
        {
            bool success = itemStack.item.Use();
            if (success)
            {
                if (!itemStack.item.reusable)
                {
                    itemStack.amount--;
                    UpdateSlot(slotID, itemStack);
                }
                return;
            }
        }
        UIUtil.Main.ShowMessage("No Effect", 2f);
    }

    public bool CanAddItem(ItemStack item)
    {
        int freeSpaces = 0;

        freeSpaces += FreeSlotCount * item.item.maxStack;
        foreach (KeyValuePair<string, ItemStack> kv in containedItems)
        {
            if (kv.Value.item == item.item) // Check if they are the same SO instance
                freeSpaces += item.item.maxStack - kv.Value.amount;
        }
        return freeSpaces >= item.amount;
    }

    // Adds/removes amount out of any slot
    // Takes maxStack and number of slots into consideration
    public bool TryAlter(ItemStack item)
    {
        if (item.amount == 0)
            throw new Exception("Cannot add/remove an amount of zero items.");

        if (item.amount > 0)
        {
            // Amount is positive, must add!
            foreach (KeyValuePair<string, ItemStack> kv in containedItems)
            {
                if (kv.Value.item == item.item)
                {
                    int freeSpaces = kv.Value.item.maxStack - kv.Value.amount;
                    int amountToPlace = Mathf.Min(item.amount, freeSpaces);
                    item.amount -= amountToPlace;
                    kv.Value.amount += amountToPlace;
                    UpdateSlot(kv.Key, kv.Value);
                    if (item.amount == 0)
                        return true;
                }
            }

            foreach (string id in SlotIDs)
            {
                if (!containedItems.ContainsKey(id) && id[0] != 'E')
                {
                    int amountToPlace = Mathf.Min(item.amount, item.item.maxStack);
                    item.amount -= amountToPlace;
                    ItemStack newItem = new ItemStack(item.item, amountToPlace);
                    containedItems.Add(id, newItem);
                    UpdateSlot(id, newItem);
                }
                if (item.amount == 0)
                    return true;
            }
        }
        else
        {
            // Amount is negative, must take!
            foreach (KeyValuePair<string, ItemStack> kv in containedItems)
            {
                if (kv.Value.item == item.item)
                {
                    int amountTaken = Mathf.Max(item.amount, -kv.Value.amount);
                    item.amount -= amountTaken;
                    kv.Value.amount += amountTaken;
                    ContainerManager.Main.UpdateSlotUI(kv.Key, kv.Value);
                    if (item.amount == 0)
                        return true;
                }
            }
        }

        return false;
    }

    public void OverwriteSlot(string slotID, ItemStack itemSlot)
    {
        ClearSlot(slotID);
        if (itemSlot.item != null && itemSlot.amount > 0)
        {
            containedItems.Add(slotID, itemSlot);
            UpdateSlot(slotID, itemSlot);
        }
    }

    public ItemStack Peek(string slotID)
    {
        ItemStack item;
        containedItems.TryGetValue(slotID, out item);
        return item;
    }

    public virtual void ClearSlot(string slotID)
    {
        containedItems.Remove(slotID);
        ContainerManager.Main.UpdateSlotUI(slotID, null);
    }

    public void UpdateSlot(string slotID, ItemStack itemStack)
    {
        if (itemStack.amount < 1)
        {
            ClearSlot(slotID);
            return;
        }

        ContainerManager.Main.UpdateSlotUI(slotID, itemStack);
    }

    public override string ToString()
    {
        string allItems = string.Empty;

        foreach (KeyValuePair<string, ItemStack> kv in containedItems)
        {
            allItems += string.Concat(kv.Key, ": ", kv.Value.amount, " ", kv.Value.item.name, " / ");
        }
        return allItems;
    }

    #region SERIALIZATION

    public ItemContainerData GetData()
    {
        return new ItemContainerData(containedItems);
    }

    public virtual void SetData(ItemContainerData itemContainerData)
    {
        containedItems.Clear();

        foreach (ContainedItemEntry entry in itemContainerData.containedItemEntries)
        {
            containedItems.Add(entry.slotID, new ItemStack(entry.itemContainerData));
        }
    }
}

[Serializable]
public class ItemContainerData
{
    public ContainedItemEntry[] containedItemEntries;

    public ItemContainerData(Dictionary<string, ItemStack> containedItems)
    {
        containedItemEntries = new ContainedItemEntry[containedItems.Count];

        int i = 0;
        foreach (KeyValuePair<string, ItemStack> kv in containedItems)
        {
            containedItemEntries[i] = new ContainedItemEntry(kv.Key, kv.Value);
            i++;
        }
    }
}

[Serializable]
public class ContainedItemEntry
{
    public string slotID;

    public ItemStackData itemContainerData;

    public ContainedItemEntry(string slotID, ItemStack itemStack)
    {
        this.slotID = slotID;

        itemContainerData = new ItemStackData(itemStack);
    }
}

#endregion


---
Script: ItemStash.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ItemStash.cs)

﻿using UnityEngine;
using System.Collections;

public class ItemStash : ItemContainer
{
    public static string[] slotIDs;

    public override string[] SlotIDs { get => slotIDs; }

    public override int Capacity { get => slotIDs.Length; }
}

---
Script: Block.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Block.cs)

﻿using UnityEngine;
using System.Collections;

[CreateAssetMenu(fileName = "Block", menuName = "Item/Block")]
public class Block : Item
{
    public Voxel voxelType;

    public override bool Use()
    {
        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Consts.InteractionDistance, Consts.VoxelMask))
        {
            TerrainManager.Main.SetVoxel(hit.point - ray.direction * 0.01f, voxelType);
            return true;
        }
        return false;
    }
}

---
Script: Equiment.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Equiment.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

public enum EquipmentType : byte { Weapon, Tool, Head, Torso, Legs, Feet, Cloak, Necklace, Ring, Lightsource };

[System.Serializable]
public class Enchantment
{
    public string attributeName;
    public float value;
    public string description;
}

public class Equipment : Item
{
    public EquipmentType type;

    public int meleeDamage;

    public int rangedDamage;

    public int armor;

    public List<Enchantment> enchantments = new List<Enchantment>();

    // Copy gets created in case of player enchantment.
    public Equipment Enchant(Enchantment enchantment)
    {
        Equipment e = Instantiate(this);
        id = System.Guid.NewGuid().ToString();
        e.isUnique = true;
        e.enchantments.Add(enchantment);
        return e;
    }

    public override string ToString()
    {
        throw new NotImplementedException();
    }

    public override ItemData GetData()
    {
        return new EquipmentData(this);
    }

    public override void SetData(ItemData data)
    {
        if (!(data is EquipmentData))
            throw new Exception("Feeded wrong itemdata type.");

        EquipmentData ed = (EquipmentData)data;

        this.name = ed.itemName;
        this.meleeDamage = ed.meleeDamage;
        this.rangedDamage = ed.rangedDamage;
        this.armor = ed.armor;
        this.enchantments = new List<Enchantment>(ed.enchantments);
        // WIP
    }

    public override bool Use()
    {
        return false;
    }
}

[System.Serializable]
public class EquipmentData : ItemData
{
    public int meleeDamage, rangedDamage, armor;

    public Enchantment[] enchantments;

    public EquipmentData(Equipment equipment) : base(equipment)
    {
        this.meleeDamage = equipment.meleeDamage;
        this.rangedDamage = equipment.rangedDamage;
        this.armor = equipment.armor;
        this.enchantments = equipment.enchantments.ToArray();
    }
}

---
Script: Item.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Item.cs)

﻿using UnityEngine;
using System.Collections;
using System;

public enum ItemPivot : byte { Bottom, MidCenter, MidCorner, Top };

public enum SnapType : byte { Center, Edge, Corner };
public abstract class Item : ScriptableObject
{
    [HideInInspector]
    public string id = System.Guid.NewGuid().ToString();

    [Tooltip("Inventory thumb")]
    public Sprite thumbnail;
    [Tooltip("Item prefab (world rep)")]
    public GameObject prefab;
    [Tooltip("MUST BE UNIQUE!")]
    public new string name;
    [TextArea] public string description;
    public bool reusable;
    public int maxStack = 1; // Customizable items must have maxStack = 1.
    //public bool isSolid;
    public Vector3 volume = Vector3.one;
    public ItemPivot pivot = ItemPivot.Bottom;
    public SnapType snapType = SnapType.Center;

    public bool isUnique;

    public virtual Item GetCopy()
    {
        return this;
    }

    public override string ToString()
    {
        return string.Concat(name, " - ", GetType().FullName, "\n", description);
    }

    public virtual ItemData GetData()
    {
        return new ItemData(this);
    }

    public virtual void SetData(ItemData data)
    {
        // Do absolutely nothing
    }

    public abstract bool Use();

    public virtual bool ValidatePlacement(Vector3 volumeCenter)
    {
        // No orientation or layermask for now
        if (Physics.OverlapBox(volumeCenter, (volume / 2f) - ItemUtil.CollisionAllowance).Length == 0)
        {
            return true;
        }

        return false;
    }

    // REVIEW THIS
    public virtual bool ValidatePopulation(Vector3 volumeCenter)
    {
        Vector3 fixedVolumeCenter = volumeCenter + Vector3.one * .1f;

        for (float x = -volume.x / 2f; x < volume.x / 2f; x++)
        {
            for (float y = -volume.y / 2f; y < volume.y / 2f; y++)
            {
                for (float z = -volume.z / 2f; z < volume.z / 2f; z++)
                {
                    Voxel v = Voxel.Object;
                    TerrainManager.Main.GetVoxel(fixedVolumeCenter + new Vector3(x, y, z), out v);
                    if (v != Voxel.Air)
                        return false;
                }
            }
        }

        return true;
    }

    public bool SpawnPrefab()
    {
        Ray ray = Camera.main.ViewportPointToRay(new Vector3(0.5f, 0.5f, 0));
        RaycastHit hit;

        if (Physics.Raycast(ray, out hit, Consts.InteractionDistance, Consts.VoxelMask))
        {
            if (SpawnManager.Main.TrySpawnItem(ray.direction, hit.point - ray.direction * 0.01f, ContainerManager.Main.GetSelectedSlotID()))
                return true;
        }
        return false;
    }
}

[Serializable]
public class ItemData
{
    public string itemName;

    public ItemData(Item item)
    {
        this.itemName = item.name;
    }
}
---
Script: NPC.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\NPC.cs)

﻿using UnityEngine;
using System.Collections;
using System;

[CreateAssetMenu(fileName = "NPC", menuName = "Item/NPC")]
public class NPC : Item
{
    public override bool Use()
    {
        return SpawnPrefab();
    }
}
---
Script: EquipmentSlot.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\EquipmentSlot.cs)

﻿using UnityEngine;
using System.Collections;

public class EquipmentSlot : ItemSlot
{
    public EquipmentType equipmentType;

    public Sprite filler;

    public override void ClearItemRep()
    {
        SetSprite(filler);
        Brighten();
        amountText.enabled = false;
        itemStack = null;
    }
}
---
Script: ImageController.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\ImageController.cs)

﻿using UnityEngine;
using System.Collections;
using UnityEngine.UI;

public class ImageController : MonoBehaviour
{
    static Color dimColor = new Color(1, 1, 1, .5f);
    static Color transparentColor = new Color(1, 1, 1, 0);

    [SerializeField] protected Image image;
    [SerializeField] protected Transform myTransform;

    public void SetSprite(Sprite sprite)
    {
        this.image.sprite = sprite;
    }

    public Sprite GetSprite()
    {
        return this.image.sprite;
    }

    public void SetPosition(Vector3 worldPosition)
    {
        transform.position = worldPosition;
    }

    public void Show()
    {
        image.gameObject.SetActive(true);
    }

    public void Hide()
    {
        image.gameObject.SetActive(false);
    }

    public void Brighten()
    {
        image.color = Color.white;
    }

    public void Dim()
    {
        image.color = dimColor;
    }

    public void Transparent()
    {
        image.color = transparentColor;
    }

}

---
Script: ItemSlot.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\ItemSlot.cs)

﻿using UnityEngine;
using System.Collections;
using TMPro;
using UnityEngine.UI;
using UnityEngine.EventSystems;
using System.Collections.Generic;
using System;

public class ItemSlot : ImageController, IPointerEnterHandler, IPointerExitHandler, IPointerClickHandler
{
    [SerializeField] protected TMP_Text amountText;
    public ItemStack itemStack;

    public string ID { get { return gameObject.name; } }

    public virtual void SetItemRep(ItemStack itemStack)
    {
        SetSprite(itemStack.item.thumbnail); // Null ref here
        amountText.text = itemStack.amount.ToString();

        if (itemStack.amount != 1)
            amountText.enabled = true;
        else
            amountText.enabled = false;

        this.itemStack = itemStack;
        Brighten();
        Show();
    }

    public virtual void ClearItemRep()
    {
        this.itemStack = null;
        Hide();
    }

    public void OnPointerEnter(PointerEventData eventData)
    {
        if (itemStack != null)
            ContainerManager.Main.ShowTooltip(this);
    }

    public void OnPointerExit(PointerEventData eventData)
    {
        if (itemStack != null)
            ContainerManager.Main.HideTooptip();
    }

    public void OnPointerClick(PointerEventData eventData)
    {
        if (eventData.button == PointerEventData.InputButton.Left)
        {
            ContainerManager.Main.PickSlot(this);
        }
        else if (eventData.button == PointerEventData.InputButton.Right)
        {
            ContainerManager.Main.PickSlot(this, true);
        }
    }
}

---
Script: Tooltip.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\Tooltip.cs)

﻿using UnityEngine;
using System.Collections;
using TMPro;

public class Tooltip : ImageController
{
    [SerializeField] TMP_Text text;

    public void SetText(string text)
    {
        this.text.text = text;
    }
}

---
Script: UIUtil.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\UIUtil.cs)

﻿using UnityEngine;
using System.Collections;
using TMPro;

public class UIUtil : Singleton<UIUtil>
{
    public GameObject messageBox;
    public TMP_Text messageBoxText;

    public void ShowMessage(string message, float exibitionTime)
    {
        messageBoxText.text = message;
        messageBox.SetActive(true);
        Invoke("HideMessage", exibitionTime);
    }

    public void HideMessage()
    {
        messageBox.SetActive(false);
    }
}

---
Script: WorldObject.cs (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\WorldObjects\WorldObject.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

public class WorldObject : MonoBehaviour
{

    public ItemStack itemStack;

    bool isInitialized = false;

    //protected new Transform transform;

    protected virtual void Start()
    {
        if (!isInitialized)
        {
            throw new Exception("WorldItem must be initialized.");
        }

        //transform = base.transform;
    }

    public virtual void Initialize(Vector3 position, Quaternion rotation, Vector3 scale, ItemStack itemStack)
    {
        transform.position = position;
        transform.rotation = rotation;
        transform.localScale = scale;
        this.itemStack = itemStack;
        isInitialized = true;
    }

    public virtual void Interact()
    {
        ReturnToInventory();
    }

    public bool ReturnToInventory()
    {
        if (ContainerManager.Main.TryAlterContainer(itemStack))
        {
            TerrainManager.Main.RemoveItem(this);
            Destroy(gameObject);
            return true;
        }
        UIUtil.Main.ShowMessage("Inventory is full", 1f);
        return false;
    }

    #region SERIALIZATION

    public virtual WorldObjectData GetData()
    {
        return new WorldObjectData(transform, itemStack);
    }

    public virtual void SetData(WorldObjectData data)
    {
        Vector3 position = new Vector3(data.position[0], data.position[1], data.position[2]);
        Quaternion rotation = Quaternion.Euler(data.rotation[0], data.rotation[1], data.rotation[2]);
        Vector3 scale = new Vector3(data.scale[0], data.scale[1], data.scale[2]);

        itemStack = new ItemStack(data.itemStackData);

        Initialize(position, rotation, scale, itemStack);
    }
}

[System.Serializable]
public class WorldObjectData : WorldPlacementData
{
    public ItemStackData itemStackData;

    public WorldObjectData(Transform transform, ItemStack itemStack) : base(transform)
    {
        itemStackData = new ItemStackData(itemStack);
    }
}

#endregion


---
Script: LoadMenu.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\LoadMenu.cs)

﻿using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine;
using UnityEngine.UI;

public class LoadMenu : MonoBehaviour
{
    public GameObject saveslot;
    public Transform saveContainer;
    public GameObject noSavesFoundMessage;

    List<GameObject> createdSlots = new List<GameObject>();

    public void LoadSlot(string slotName)
    {
        SaveManager.Main.Load(slotName);
    }

    public void DeleteSlot(string slotName)
    {
        SaveManager.Main.DeleteSave(slotName);
        Reset();
    }

    public void Reset()
    {
        OnDisable();
        OnEnable();
    }

    private void OnEnable()
    {
        string[] saveNames = SaveUtil.GetAllSaveNames(true);

        if (saveNames.Length > 0)
            noSavesFoundMessage.SetActive(false);

        foreach (string saveName in saveNames)
        {
            GameObject g = Instantiate(saveslot, saveContainer);
            g.GetComponentInChildren<TMP_Text>().text = saveName;
            Button[] buttons = g.GetComponentsInChildren<Button>();
            buttons[0].onClick.AddListener(delegate { LoadSlot(saveName); });

            if (saveName == "autosave")
                buttons[1].gameObject.SetActive(false);
            else
                buttons[1].onClick.AddListener(delegate { DeleteSlot(saveName); });

            createdSlots.Add(g);
        }
    }

    private void OnDisable()
    {
        foreach (GameObject slot in createdSlots)
        {
            Destroy(slot);
        }
        createdSlots.Clear();
        noSavesFoundMessage.SetActive(true);
    }
}

---
Script: NewSaveMenu.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\NewSaveMenu.cs)

﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;
using TMPro;

public class NewSaveMenu : MonoBehaviour
{

    public TMP_InputField newSaveInputField;
    public Button createSaveButton;

    public void CreateSave()
    {
        string newSaveName = newSaveInputField.text;

        SaveManager.Main.Save(newSaveName);
    }

    public void CheckName()
    {
        bool isValid = SaveUtil.ValidateSaveName(newSaveInputField.text);

        if (isValid)
            createSaveButton.interactable = true;
        else
            createSaveButton.interactable = false;
    }

    private void OnEnable()
    {
        newSaveInputField.onValueChanged.AddListener(delegate { CheckName(); });
        newSaveInputField.text = string.Empty;
    }

    private void OnDisable()
    {
        newSaveInputField.onValueChanged.RemoveListener(delegate { CheckName(); });
    }
}

---
Script: PauseMenu.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\PauseMenu.cs)

﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class PauseMenu : MonoBehaviour
{
    bool isVisible = false;

    public GameObject pausePanel;
    public GameObject HUDCenter;
    public GameObject[] otherPanels;

    private void Start()
    {
        Hide();
    }

    private void Update()
    {
        // TO DO: USE NEW INPUT SYSTEM!!!
        if (Input.GetKeyDown(KeyCode.Escape))
        {
            if (isVisible)
                Hide();
            else
                Show();
        }
    }

    public void Show()
    {
        pausePanel.SetActive(true);
        HUDCenter.SetActive(false);
        foreach (GameObject panel in otherPanels)
        {
            panel.SetActive(false);
        }
        isVisible = true;
        GameController.IsPaused = true;
    }

    public void Hide()
    {
        pausePanel.SetActive(false);
        HUDCenter.SetActive(true);
        foreach (GameObject panel in otherPanels)
        {
            panel.SetActive(false);
        }
        isVisible = false;
        GameController.IsPaused = false;
    }
}

---
Script: SaveManager.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveManager.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.SceneManagement;

public delegate void AutosaveHandler();

public class SaveManager : Singleton<SaveManager>
{
    [SerializeField]
    string gameScene = "VoxelWorld";

    public static AutosaveHandler OnAutosave;

    private void Awake()
    {
        string autosavePath = SaveUtil.GetAutosavePath();
        Directory.CreateDirectory(autosavePath);
    }

    public void NewGame()
    {
        CleanAutosave();
        SceneManager.LoadScene(gameScene);
    }

    public void Save(string saveName)
    {
        string savePath = SaveUtil.GetSavePath(saveName);
        Directory.CreateDirectory(savePath);

        StartCoroutine(ProcessSave(savePath));
    }

    public IEnumerator ProcessSave(string savePath)
    {
        yield return new WaitForEndOfFrame();

        string autosavePath = SaveUtil.GetAutosavePath();

        // Save player data (pos, stats, inv)
        PlayerManager.Main.Save();

        // Save all voxels and world items (including chests)
        TerrainManager.Main.SaveAll();


        // Clean TargetSave
        CleanSave(savePath);

        // AutoSave -> TargetSave
        foreach (string file in Directory.GetFiles(autosavePath))
        {
            File.Copy(file, Path.Combine(savePath, Path.GetFileName(file)), true);
        }
    }

    public void Load(string saveName)
    {
        SceneManager.LoadScene(gameScene);
        string savePath = SaveUtil.GetSavePath(saveName);
        string autosavePath = SaveUtil.GetAutosavePath();

        CleanAutosave();

        // TargetSave -> AutoSave
        foreach (string file in Directory.GetFiles(savePath))
        {
            File.Copy(file, Path.Combine(autosavePath, Path.GetFileName(file)), true);
        }

        // Player data gets loaded by PlayerManager
        // Chunks get loaded by TerrainManager
    }

    public void CleanAutosave()
    {
        string autosavePath = SaveUtil.GetAutosavePath();
        System.IO.DirectoryInfo di = new DirectoryInfo(autosavePath);
        foreach (FileInfo file in di.EnumerateFiles())
        {
            file.Delete();
        }
    }

    public void CleanSave(string savePath)
    {
        System.IO.DirectoryInfo di = new DirectoryInfo(savePath);
        foreach (FileInfo file in di.EnumerateFiles())
        {
            file.Delete();
        }
    }

    public void DeleteSave(string saveName)
    {
        string savePath = SaveUtil.GetSavePath(saveName);
        Directory.Delete(savePath, true);
    }

    public void QuitGame()
    {
        Application.Quit();
    }
}

---
Script: SaveMenu.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveMenu.cs)

﻿using UnityEngine;
using System.Collections;
using TMPro;
using System.Collections.Generic;
using UnityEngine.UI;
using System;
using System.Text.RegularExpressions;

public class SaveMenu : MonoBehaviour
{
    public GameObject saveslot;
    public GameObject noSavesFoundMessage;
    public Transform saveContainer;
    public GameObject overwritePopup;

    List<GameObject> createdSlots = new List<GameObject>();

    public void OverwriteConfirmation(string slotName)
    {
        gameObject.SetActive(false);
        overwritePopup.SetActive(true);
        Button[] buttons = overwritePopup.GetComponentsInChildren<Button>();
        buttons[0].onClick.RemoveAllListeners();
        buttons[0].onClick.AddListener(delegate { SaveOnSlot(slotName); });
    }

    public void SaveOnSlot(string slotName)
    {
        DeleteSlot(slotName);
        string newSaveName = SaveUtil.GetSaveFileName();
        SaveManager.Main.Save(newSaveName);
        Reset();
    }

    public void CreateSave()
    {
        string newSaveName = SaveUtil.GetSaveFileName();
        SaveManager.Main.Save(newSaveName);
        Reset();
    }

    public void DeleteSlot(string slotName)
    {
        SaveManager.Main.DeleteSave(slotName);
        Reset();
    }

    public void Reset()
    {
        OnDisable();
        OnEnable();
    }

    private void OnEnable()
    {
        string[] saveNames = SaveUtil.GetAllSaveNames();

        if (saveNames.Length > 0)
            noSavesFoundMessage.SetActive(false);

        foreach (string saveName in saveNames)
        {
            GameObject g = Instantiate(saveslot, saveContainer);
            g.GetComponentInChildren<TMP_Text>().text = saveName;
            Button[] buttons = g.GetComponentsInChildren<Button>();
            buttons[0].onClick.AddListener(delegate { OverwriteConfirmation(saveName); });
            buttons[1].onClick.AddListener(delegate { DeleteSlot(saveName); });
            createdSlots.Add(g);
        }
    }

    private void OnDisable()
    {
        foreach (GameObject slot in createdSlots)
        {
            Destroy(slot);
        }
        createdSlots.Clear();
        noSavesFoundMessage.SetActive(true);
    }
}

---
Script: SaveUtil.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveUtil.cs)

﻿using UnityEngine;
using System.Collections;
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.Generic;

public static class SaveUtil
{
    public static string GetSavedataPath()
    {
        return String.Concat(String.Concat(Application.persistentDataPath, "/savedata/"));
    }

    public static string[] GetAllSaveNames(bool includeAutosave = false)
    {
        List<string> paths = Directory.GetDirectories(String.Concat(Application.persistentDataPath, "/savedata/")).Select(Path.GetFileName).ToList();
        if(!includeAutosave)
            paths.RemoveAll(path => path.Contains("autosave"));

        return paths.ToArray();
    }

    public static string GetSavePath(string saveName)
    {
        return String.Concat(Application.persistentDataPath, "/savedata/", saveName);
    }

    public static string GetSaveFileName()
    {
        return Regex.Replace(DateTime.Now.ToString(), @"[^a-zA-Z0-9]+", "-").Trim('-');
    }

    public static string GetAutosavePath()
    {
        return String.Concat(Application.persistentDataPath, "/savedata/autosave/");
    }

    public static string GetChunkVoxelPath(Vector3Int chunkPosition)
    {
        return String.Concat(GetAutosavePath(), GetChunkFileName(chunkPosition), "(V).chunk");
    }

    public static string GetChunkObjectPath(Vector3Int chunkPosition)
    {
        return String.Concat(GetAutosavePath(), GetChunkFileName(chunkPosition), "(O).chunk");
    }

    public static string GetChunkPath(Vector3Int chunkPosition)
    {
        return String.Concat(GetAutosavePath(), GetChunkFileName(chunkPosition), ".chunk");
    }

    public static string GetChunkFileName(Vector3Int chunkPosition)
    {
        return String.Concat(
            chunkPosition.x, "_",
            chunkPosition.y, "_",
            chunkPosition.z
        );
    }

    public static string GetPlayerDataPath()
    {
        return String.Concat(GetAutosavePath(), "PlayerData.xuxa");
    }

    public static bool ValidateSaveName(string saveName)
    {
        if (string.IsNullOrEmpty(saveName))
        {
            return false;
        }
        string[] oldSaveNames = GetAllSaveNames();
        foreach (string oldSaveName in oldSaveNames)
        {
            if (saveName == oldSaveName)
            {
                return false;
            }
        }
        // Passed all checks, good to go.
        return true;
    }

    public static byte VoxelToByte(Voxel v)
    {
        return (byte)v;
    }

    public static Voxel ByteToVoxel(byte b)
    {
        return (Voxel)b;
    }
}

---
Script: WorldPlacementData.cs (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\DataClasses\WorldPlacementData.cs)

﻿using UnityEngine;
using System.Collections;

[System.Serializable]
public class WorldPlacementData
{
    public float[] position = new float[3];
    public float[] rotation = new float[3];
    public float[] scale = new float[3];

    public WorldPlacementData(Transform transform)
    {
        position[0] = transform.position.x;
        position[1] = transform.position.y;
        position[2] = transform.position.z;

        Vector3 rotEuler = transform.rotation.eulerAngles;
        rotation[0] = rotEuler.x;
        rotation[1] = rotEuler.y;
        rotation[2] = rotEuler.z;

        scale[0] = transform.localScale.x;
        scale[1] = transform.localScale.y;
        scale[2] = transform.localScale.z;
    }
}

---
Script: CollisionChecker.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\CollisionChecker.cs)

﻿using UnityEngine;
using System.Collections;

public class CollisionChecker : MonoBehaviour
{
    public delegate void CheckEndHandler(bool isOverlapping);
    public event CheckEndHandler CheckEnded;

    bool isColliding = false;

    private void Awake()
    {
        StartCoroutine(CheckOnNextFrame());
    }

    IEnumerator CheckOnNextFrame()
    {
        yield return null;
        yield return null; // waits two frames

        CheckEnded?.Invoke(isColliding);

        print("IS COLLIDING = " + isColliding);

        Destroy(gameObject);
    }

    private void OnCollisionEnter(Collision collision)
    {
        isColliding = true;
    }

    private void OnTriggerEnter(Collider other)
    {
        isColliding = true;
    }

    private void OnCollisionStay(Collision collision)
    {
        isColliding = true;
    }

    private void OnTriggerStay(Collider other)
    {
        isColliding = true;
    }
}

---
Script: MouseHandler.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\MouseHandler.cs)

﻿using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.UI;

public class MouseHandler : MonoBehaviour
{
    public Transform cursorImageTransform;
    public Image cursorImage;

    public bool disableOnStart;

    bool lastPauseState;

    private void Start()
    {
        if (disableOnStart)
        {
            Cursor.visible = false;
            LockMouse();
        }
    }

    public void UnlockMouse()
    {
        Cursor.lockState = CursorLockMode.None;
        cursorImage.enabled = true;
        lastPauseState = GameController.IsPaused;
    }

    public void LockMouse()
    {
        Cursor.lockState = CursorLockMode.Locked;
        cursorImage.enabled = false;
        lastPauseState = GameController.IsPaused;
    }

    private void Update()
    {
        if (GameController.IsPaused != lastPauseState)
        {
            if (GameController.IsPaused)
                UnlockMouse();
            else
                LockMouse();
        }
        if (GameController.isPaused)
        {
            cursorImageTransform.position = Input.mousePosition;
        }
    }
}

---
Script: NativeCounter.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\NativeCounter.cs)

﻿using System;
using System.Runtime.InteropServices;
using System.Threading;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Jobs.LowLevel.Unsafe;

[StructLayout(LayoutKind.Sequential)]
[NativeContainer]
public unsafe struct NativeCounter
{
    // The actual pointer to the allocated count needs to have restrictions relaxed so jobs can be schedled with this container
    [NativeDisableUnsafePtrRestriction]
    int* m_Counter;

#if ENABLE_UNITY_COLLECTIONS_CHECKS
    AtomicSafetyHandle m_Safety;
    // The dispose sentinel tracks memory leaks. It is a managed type so it is cleared to null when scheduling a job
    // The job cannot dispose the container, and no one else can dispose it until the job has run so it is ok to not pass it along
    // This attribute is required, without it this native container cannot be passed to a job since that would give the job access to a managed object
    [NativeSetClassTypeToNullOnSchedule]
    DisposeSentinel m_DisposeSentinel;
#endif

    // Keep track of where the memory for this was allocated
    Allocator m_AllocatorLabel;

    public NativeCounter(Allocator label)
    {
        // This check is redundant since we always use an int which is blittable.
        // It is here as an example of how to check for type correctness for generic types.
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        if (!UnsafeUtility.IsBlittable<int>())
            throw new ArgumentException(string.Format("{0} used in NativeQueue<{0}> must be blittable", typeof(int)));
#endif
        m_AllocatorLabel = label;

        // Allocate native memory for a single integer
        m_Counter = (int*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<int>(), 4, label);

        // Create a dispose sentinel to track memory leaks. This also creates the AtomicSafetyHandle
#if ENABLE_UNITY_COLLECTIONS_CHECKS
#if UNITY_2018_3_OR_NEWER
        DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, 0, label);
#else
        DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, 0);
#endif
#endif
        // Initialize the count to 0 to avoid uninitialized data
        Count = 0;
    }

    public int Increment()
    {
        // Verify that the caller has write permission on this data.
        // This is the race condition protection, without these checks the AtomicSafetyHandle is useless
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
        (*m_Counter)++;
        return (*m_Counter) - 1;
    }

    public int Count
    {
        get
        {
            // Verify that the caller has read permission on this data.
            // This is the race condition protection, without these checks the AtomicSafetyHandle is useless
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckReadAndThrow(m_Safety);
#endif
            return *m_Counter;
        }
        set
        {
            // Verify that the caller has write permission on this data. This is the race condition protection, without these checks the AtomicSafetyHandle is useless
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
            *m_Counter = value;
        }
    }

    public bool IsCreated
    {
        get { return m_Counter != null; }
    }

    public void Dispose()
    {
        // Let the dispose sentinel know that the data has been freed so it does not report any memory leaks
#if ENABLE_UNITY_COLLECTIONS_CHECKS
#if UNITY_2018_3_OR_NEWER
        DisposeSentinel.Dispose(ref m_Safety, ref m_DisposeSentinel);
#else
        DisposeSentinel.Dispose(m_Safety, ref m_DisposeSentinel);
#endif
#endif

        UnsafeUtility.Free(m_Counter, m_AllocatorLabel);
        m_Counter = null;
    }

    public Concurrent ToConcurrent()
    {
        Concurrent concurrent;

#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
        concurrent.m_Safety = m_Safety;
        AtomicSafetyHandle.UseSecondaryVersion(ref concurrent.m_Safety);
#endif

        concurrent.m_Counter = m_Counter;
        return concurrent;
    }

    [NativeContainer]
    // This attribute is what makes it possible to use NativeCounter.Concurrent in a ParallelFor job
    [NativeContainerIsAtomicWriteOnly]
    unsafe public struct Concurrent
    {
        // Copy of the pointer from the full NativeCounter
        [NativeDisableUnsafePtrRestriction]
        internal int* 	m_Counter;

        // Copy of the AtomicSafetyHandle from the full NativeCounter. The dispose sentinel is not copied since this inner struct does not own the memory and is not responsible for freeing it
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
        internal AtomicSafetyHandle m_Safety;
    #endif

        public int Increment()
        {
            // Increment still needs to check for write permissions
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
    #endif
            // The actual increment is implemented with an atomic since it can be incremented by multiple threads at the same time
            return Interlocked.Increment(ref *m_Counter) - 1;
        }
    }
}

[StructLayout(LayoutKind.Sequential)]
[NativeContainer]
public unsafe struct NativePerThreadCounter
{
    // The actual pointer to the allocated count needs to have restrictions relaxed so jobs can be schedled with this container
    [NativeDisableUnsafePtrRestriction]
    int* m_Counter;

#if ENABLE_UNITY_COLLECTIONS_CHECKS
    AtomicSafetyHandle m_Safety;
    // The dispose sentinel tracks memory leaks. It is a managed type so it is cleared to null when scheduling a job
    // The job cannot dispose the container, and no one else can dispose it until the job has run so it is ok to not pass it along
    // This attribute is required, without it this native container cannot be passed to a job since that would give the job access to a managed object
    [NativeSetClassTypeToNullOnSchedule]
    DisposeSentinel m_DisposeSentinel;
#endif

    // Keep track of where the memory for this was allocated
    Allocator m_AllocatorLabel;

    public const int IntsPerCacheLine = JobsUtility.CacheLineSize / sizeof(int);

    public NativePerThreadCounter(Allocator label)
    {
        // This check is redundant since we always use an int which is blittable.
        // It is here as an example of how to check for type correctness for generic types.
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        if (!UnsafeUtility.IsBlittable<int>())
            throw new ArgumentException(string.Format("{0} used in NativeQueue<{0}> must be blittable", typeof(int)));
#endif
        m_AllocatorLabel = label;

        // One full cache line (integers per cacheline * size of integer) for each potential worker index, JobsUtility.MaxJobThreadCount
        m_Counter = (int*)UnsafeUtility.Malloc(UnsafeUtility.SizeOf<int>()*IntsPerCacheLine*JobsUtility.MaxJobThreadCount, 4, label);

        // Create a dispose sentinel to track memory leaks. This also creates the AtomicSafetyHandle
#if ENABLE_UNITY_COLLECTIONS_CHECKS
#if UNITY_2018_3_OR_NEWER
        DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, 0, label);
#else
        DisposeSentinel.Create(out m_Safety, out m_DisposeSentinel, 0);
#endif
#endif
        // Initialize the count to 0 to avoid uninitialized data
        Count = 0;
    }

    public void Increment()
    {
        // Verify that the caller has write permission on this data.
        // This is the race condition protection, without these checks the AtomicSafetyHandle is useless
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
        (*m_Counter)++;
    }

    public int Count
    {
        get
        {
            // Verify that the caller has read permission on this data.
            // This is the race condition protection, without these checks the AtomicSafetyHandle is useless
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckReadAndThrow(m_Safety);
    #endif
            int count = 0;
            for (int i = 0; i < JobsUtility.MaxJobThreadCount; ++i)
                count += m_Counter[IntsPerCacheLine * i];
            return count;
        }
        set
        {
            // Verify that the caller has write permission on this data.
            // This is the race condition protection, without these checks the AtomicSafetyHandle is useless
    #if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
    #endif
            // Clear all locally cached counts,
            // set the first one to the required value
            for (int i = 1; i < JobsUtility.MaxJobThreadCount; ++i)
                m_Counter[IntsPerCacheLine * i] = 0;
            *m_Counter = value;
        }
    }

    public bool IsCreated
    {
        get { return m_Counter != null; }
    }

    public void Dispose()
    {
        // Let the dispose sentinel know that the data has been freed so it does not report any memory leaks
#if ENABLE_UNITY_COLLECTIONS_CHECKS
#if UNITY_2018_3_OR_NEWER
        DisposeSentinel.Dispose(ref m_Safety, ref m_DisposeSentinel);
#else
        DisposeSentinel.Dispose(m_Safety, ref m_DisposeSentinel);
#endif
#endif

        UnsafeUtility.Free(m_Counter, m_AllocatorLabel);
        m_Counter = null;
    }

    public Concurrent ToConcurrent()
    {
        Concurrent concurrent;
#if ENABLE_UNITY_COLLECTIONS_CHECKS
        AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
        concurrent.m_Safety = m_Safety;
        AtomicSafetyHandle.UseSecondaryVersion(ref concurrent.m_Safety);
#endif

        concurrent.m_Counter = m_Counter;
        concurrent.m_ThreadIndex = 0;
        return concurrent;
    }

    [NativeContainer]
    [NativeContainerIsAtomicWriteOnly]
    // Let the JobSystem know that it should inject the current worker index into this container
    unsafe public struct Concurrent
    {
        [NativeDisableUnsafePtrRestriction]
        internal int* 	m_Counter;

    #if ENABLE_UNITY_COLLECTIONS_CHECKS
        internal AtomicSafetyHandle m_Safety;
    #endif

        // The current worker thread index, it must use this exact name since it is injected
        [NativeSetThreadIndex]
        internal int m_ThreadIndex;

        public void Increment()
        {
#if ENABLE_UNITY_COLLECTIONS_CHECKS
            AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
#endif
            // No need for atomics any more since we are just incrementing the local count
            ++m_Counter[IntsPerCacheLine*m_ThreadIndex];
        }
    }
}
---
Script: NativeHelper.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\NativeHelper.cs)

using System;
using System.Collections.Generic;
using Unity.Collections;
using Unity.Collections.LowLevel.Unsafe;

namespace OptIn.Voxel.Utils
{
    public static class NativeHelper
    {
        public static unsafe void NativeAddRange<T>(this List<T> list, NativeSlice<T> nativeSlice) where T : struct
        {
            var index = list.Count;
            var newLength = index + nativeSlice.Length;
 
            // Resize our list if we require
            if (list.Capacity < newLength)
            {
                list.Capacity = newLength;
            }
 
            var items = NoAllocHelpers.ExtractArrayFromListT(list);
            var size = UnsafeUtility.SizeOf<T>();
 
            // Get the pointer to the end of the list
            var bufferStart = (IntPtr) UnsafeUtility.AddressOf(ref items[0]);
            var buffer = (byte*)(bufferStart + (size * index));
 
            UnsafeUtility.MemCpy(buffer, nativeSlice.GetUnsafePtr(), nativeSlice.Length * (long) size);
 
            NoAllocHelpers.ResizeList(list, newLength);
        }

        public static unsafe void ManagedToNative<T>(this NativeArray<T> nativeArray, T[] array) where T : unmanaged
        {
            fixed (void* voxelPointer = array)
            {
                UnsafeUtility.MemCpy(NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(nativeArray), voxelPointer, array.Length * (long) UnsafeUtility.SizeOf<T>());
            }
        }

        public static unsafe void NativeToManaged<T>(this T[] array, NativeArray<T> nativeArray) where T : unmanaged
        {
            fixed (void* voxelPointer = array)
            {
                UnsafeUtility.MemCpy(voxelPointer, NativeArrayUnsafeUtility.GetUnsafeBufferPointerWithoutChecks(nativeArray), array.Length * (long) UnsafeUtility.SizeOf<T>());
            }
        }
    }
}
---
Script: NoAllocHelpers.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\NoAllocHelpers.cs)

﻿using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;

 /// <summary>
 /// Provides access to the internal UnityEngine.NoAllocHelpers methods.
 /// </summary>
 public static class NoAllocHelpers
 {
     private static readonly Dictionary<Type, Delegate> ExtractArrayFromListTDelegates = new Dictionary<Type, Delegate>();
     private static readonly Dictionary<Type, Delegate> ResizeListDelegates = new Dictionary<Type, Delegate>();

     /// <summary>
     /// Extract the internal array from a list.
     /// </summary>
     /// <typeparam name="T"><see cref="List{T}"/>.</typeparam>
     /// <param name="list">The <see cref="List{T}"/> to extract from.</param>
     /// <returns>The internal array of the list.</returns>
     public static T[] ExtractArrayFromListT<T>(List<T> list)
     {
         if (!ExtractArrayFromListTDelegates.TryGetValue(typeof(T), out var obj))
         {
             var ass = Assembly.GetAssembly(typeof(Mesh)); // any class in UnityEngine
             var type = ass.GetType("UnityEngine.NoAllocHelpers");
             var methodInfo = type.GetMethod("ExtractArrayFromListT", BindingFlags.Static | BindingFlags.Public).MakeGenericMethod(typeof(T));

             obj = ExtractArrayFromListTDelegates[typeof(T)] = Delegate.CreateDelegate(typeof(Func<List<T>, T[]>), methodInfo);
         }

         var func = (Func<List<T>, T[]>) obj;
         return func.Invoke(list);
     }

     /// <summary>
     /// Resize a list.
     /// </summary>
     /// <typeparam name="T"><see cref="List{T}"/>.</typeparam>
     /// <param name="list">The <see cref="List{T}"/> to resize.</param>
     /// <param name="size">The new length of the <see cref="List{T}"/>.</param>
     public static void ResizeList<T>(List<T> list, int size)
     {
         if (!ResizeListDelegates.TryGetValue(typeof(T), out var obj))
         {
             var ass = Assembly.GetAssembly(typeof(Mesh)); // any class in UnityEngine
             var type = ass.GetType("UnityEngine.NoAllocHelpers");
             var methodInfo = type.GetMethod("ResizeList", BindingFlags.Static | BindingFlags.Public).MakeGenericMethod(typeof(T));
             obj = ResizeListDelegates[typeof(T)] = Delegate.CreateDelegate(typeof(Action<List<T>, int>), methodInfo);
         }

         var action = (Action<List<T>, int>) obj;
         action.Invoke(list, size);
     }
 }
---
Script: Noise.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\Noise.cs)

﻿// Simplex NoiseNode for C#
// Copyright © Benjamin Ward 2019
// See LICENSE
// Simplex NoiseNode implementation offering 1D, 2D, and 3D forms w/ values in the range of 0 to 255.
// Based on work by Heikki Törmälä (2012) and Stefan Gustavson (2006).

using System;
using Unity.Mathematics;

namespace SimplexNoise
{
    /// <summary>
    /// Implementation of the Perlin simplex noise, an improved Perlin noise algorithm.
    /// Based loosely on SimplexNoise1234 by Stefan Gustavson: http://staffwww.itn.liu.se/~stegu/aqsis/aqsis-newnoise/
    /// </summary>
    public static class Noise
    {

        public enum Type
        {
            Normal1D,
            Normal2D,
            Normal3D,
            Fractal1D,
            Fractal2D,
            Fractal3D
        }

        public static float CalcPixel1DFractal(float x, float frequency, int octaves, float amplitude = 1.0f, float lacunarity = 2.0f, float persistence = 0.5f)
        {
            float output = 0.0f;
            float denom = 0.0f;

            for (int i = 0; i < octaves; i++)
            {
                output += (amplitude * CalcPixel1D(x, frequency));
                denom += amplitude;

                frequency *= lacunarity;
                amplitude *= persistence;
            }

            return (output / denom);
        }

        // Useful for terrain heights
        public static float CalcPixel2DFractal(float x, float y, float frequency, int octaves, float amplitude = 1.0f, float lacunarity = 2.0f, float persistence = 0.5f)
        {
            float output = 0.0f;
            float denom = 0.0f;

            for (int i = 0; i < octaves; i++)
            {
                output += (amplitude * CalcPixel2D(x, y, frequency));
                denom += amplitude;

                frequency *= lacunarity;
                amplitude *= persistence;
            }

            return (output / denom);
        }

        // Useful for caves
        public static float CalcPixel3DFractal(float x, float y, float z, float frequency, int octaves, float amplitude = 1.0f, float lacunarity = 2.0f, float persistence = 0.5f)
        {
            float output = 0.0f;
            float denom = 0.0f;

            for (int i = 0; i < octaves; i++)
            {
                output += (amplitude * CalcPixel3D(x, y, z, frequency));
                denom += amplitude;

                frequency *= lacunarity;
                amplitude *= persistence;
            }

            return (output / denom);
        }

        public static float CalcPixel1D(float x, float scale)
        {
            return (Generate(x * scale) + 1) * 0.5f;
        }

        public static float CalcPixel2D(float x, float y, float scale)
        {
            return (Generate(x * scale, y * scale) + 1) * 0.5f;
        }

        public static float CalcPixel3D(float x, float y, float z, float scale)
        {
            return (Generate(x * scale, y * scale, z * scale) + 1) * 0.5f;
        }

        private static int _seed;

        /// <summary>
        /// 1D simplex noise
        /// </summary>
        /// <param name="x"></param>
        /// <returns></returns>
        private static float Generate(float x)
        {
            var i0 = FastFloor(x);
            var i1 = i0 + 1;
            var x0 = x - i0;
            var x1 = x0 - 1.0f;

            var t0 = 1.0f - x0 * x0;
            t0 *= t0;
            var n0 = t0 * t0 * Grad(_perm[i0 & 0xff], x0);

            var t1 = 1.0f - x1 * x1;
            t1 *= t1;
            var n1 = t1 * t1 * Grad(_perm[i1 & 0xff], x1);
            // The maximum value of this noise is 8*(3/4)^4 = 2.53125
            // A factor of 0.395 scales to fit exactly within [-1,1]
            return 0.395f * (n0 + n1);
        }

        /// <summary>
        /// 2D simplex noise
        /// </summary>
        /// <param name="x"></param>
        /// <param name="y"></param>
        /// <returns></returns>
        private static float Generate(float x, float y)
        {
            const float F2 = 0.366025403f; // F2 = 0.5*(sqrt(3.0)-1.0)
            const float G2 = 0.211324865f; // G2 = (3.0-Math.sqrt(3.0))/6.0

            float n0, n1, n2; // NoiseNode contributions from the three corners

            // Skew the input space to determine which simplex cell we're in
            var s = (x + y) * F2; // Hairy factor for 2D
            var xs = x + s;
            var ys = y + s;
            var i = FastFloor(xs);
            var j = FastFloor(ys);

            var t = (i + j) * G2;
            var X0 = i - t; // Unskew the cell origin back to (x,y) space
            var Y0 = j - t;
            var x0 = x - X0; // The x,y distances from the cell origin
            var y0 = y - Y0;

            // For the 2D case, the simplex shape is an equilateral triangle.
            // Determine which simplex we are in.
            int i1, j1; // Offsets for second (middle) corner of simplex in (i,j) coords
            if (x0 > y0) { i1 = 1; j1 = 0; } // lower triangle, XY order: (0,0)->(1,0)->(1,1)
            else { i1 = 0; j1 = 1; }      // upper triangle, YX order: (0,0)->(0,1)->(1,1)

            // A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
            // a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
            // c = (3-sqrt(3))/6

            var x1 = x0 - i1 + G2; // Offsets for middle corner in (x,y) unskewed coords
            var y1 = y0 - j1 + G2;
            var x2 = x0 - 1.0f + 2.0f * G2; // Offsets for last corner in (x,y) unskewed coords
            var y2 = y0 - 1.0f + 2.0f * G2;

            // Wrap the integer indices at 256, to avoid indexing perm[] out of bounds
            var ii = Mod(i, 256);
            var jj = Mod(j, 256);

            // Calculate the contribution from the three corners
            var t0 = 0.5f - x0 * x0 - y0 * y0;
            if (t0 < 0.0f) n0 = 0.0f;
            else
            {
                t0 *= t0;
                n0 = t0 * t0 * Grad(_perm[ii + _perm[jj]], x0, y0);
            }

            var t1 = 0.5f - x1 * x1 - y1 * y1;
            if (t1 < 0.0f) n1 = 0.0f;
            else
            {
                t1 *= t1;
                n1 = t1 * t1 * Grad(_perm[ii + i1 + _perm[jj + j1]], x1, y1);
            }

            var t2 = 0.5f - x2 * x2 - y2 * y2;
            if (t2 < 0.0f) n2 = 0.0f;
            else
            {
                t2 *= t2;
                n2 = t2 * t2 * Grad(_perm[ii + 1 + _perm[jj + 1]], x2, y2);
            }

            // Add contributions from each corner to get the final noise value.
            // The result is scaled to return values in the interval [-1,1].
            return 40.0f * (n0 + n1 + n2); // TODO: The scale factor is preliminary!
        }


        private static float Generate(float x, float y, float z)
        {
            // Simple skewing factors for the 3D case
            const float F3 = 0.333333333f;
            const float G3 = 0.166666667f;

            float n0, n1, n2, n3; // NoiseNode contributions from the four corners

            // Skew the input space to determine which simplex cell we're in
            var s = (x + y + z) * F3; // Very nice and simple skew factor for 3D
            var xs = x + s;
            var ys = y + s;
            var zs = z + s;
            var i = FastFloor(xs);
            var j = FastFloor(ys);
            var k = FastFloor(zs);

            var t = (i + j + k) * G3;
            var X0 = i - t; // Unskew the cell origin back to (x,y,z) space
            var Y0 = j - t;
            var Z0 = k - t;
            var x0 = x - X0; // The x,y,z distances from the cell origin
            var y0 = y - Y0;
            var z0 = z - Z0;

            // For the 3D case, the simplex shape is a slightly irregular tetrahedron.
            // Determine which simplex we are in.
            int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords
            int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords

            /* This code would benefit from a backport from the GLSL version! */
            if (x0 >= y0)
            {
                if (y0 >= z0)
                { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // X Y Z order
                else if (x0 >= z0) { i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; } // X Z Y order
                else { i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; } // Z X Y order
            }
            else
            { // x0<y0
                if (y0 < z0) { i1 = 0; j1 = 0; k1 = 1; i2 = 0; j2 = 1; k2 = 1; } // Z Y X order
                else if (x0 < z0) { i1 = 0; j1 = 1; k1 = 0; i2 = 0; j2 = 1; k2 = 1; } // Y Z X order
                else { i1 = 0; j1 = 1; k1 = 0; i2 = 1; j2 = 1; k2 = 0; } // Y X Z order
            }

            // A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
            // a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
            // a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
            // c = 1/6.

            var x1 = x0 - i1 + G3; // Offsets for second corner in (x,y,z) coords
            var y1 = y0 - j1 + G3;
            var z1 = z0 - k1 + G3;
            var x2 = x0 - i2 + 2.0f * G3; // Offsets for third corner in (x,y,z) coords
            var y2 = y0 - j2 + 2.0f * G3;
            var z2 = z0 - k2 + 2.0f * G3;
            var x3 = x0 - 1.0f + 3.0f * G3; // Offsets for last corner in (x,y,z) coords
            var y3 = y0 - 1.0f + 3.0f * G3;
            var z3 = z0 - 1.0f + 3.0f * G3;

            // Wrap the integer indices at 256, to avoid indexing perm[] out of bounds
            var ii = Mod(i, 256);
            var jj = Mod(j, 256);
            var kk = Mod(k, 256);

            // Calculate the contribution from the four corners
            var t0 = 0.6f - x0 * x0 - y0 * y0 - z0 * z0;
            if (t0 < 0.0f) n0 = 0.0f;
            else
            {
                t0 *= t0;
                n0 = t0 * t0 * Grad(_perm[ii + _perm[jj + _perm[kk]]], x0, y0, z0);
            }

            var t1 = 0.6f - x1 * x1 - y1 * y1 - z1 * z1;
            if (t1 < 0.0f) n1 = 0.0f;
            else
            {
                t1 *= t1;
                n1 = t1 * t1 * Grad(_perm[ii + i1 + _perm[jj + j1 + _perm[kk + k1]]], x1, y1, z1);
            }

            var t2 = 0.6f - x2 * x2 - y2 * y2 - z2 * z2;
            if (t2 < 0.0f) n2 = 0.0f;
            else
            {
                t2 *= t2;
                n2 = t2 * t2 * Grad(_perm[ii + i2 + _perm[jj + j2 + _perm[kk + k2]]], x2, y2, z2);
            }

            var t3 = 0.6f - x3 * x3 - y3 * y3 - z3 * z3;
            if (t3 < 0.0f) n3 = 0.0f;
            else
            {
                t3 *= t3;
                n3 = t3 * t3 * Grad(_perm[ii + 1 + _perm[jj + 1 + _perm[kk + 1]]], x3, y3, z3);
            }

            // Add contributions from each corner to get the final noise value.
            // The result is scaled to stay just inside [-1,1]
            return 32.0f * (n0 + n1 + n2 + n3); // TODO: The scale factor is preliminary!
        }

        private static readonly byte[] _perm = {
            151,160,137,91,90,15,
            131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
            190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
            88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
            77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
            102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
            135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
            5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
            223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
            129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
            251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
            49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
            138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180,
            151,160,137,91,90,15,
            131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
            190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
            88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
            77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
            102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
            135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
            5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
            223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
            129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
            251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
            49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
            138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180
        };

        private static int FastFloor(float x)
        {
            return (x > 0) ? ((int)x) : (((int)x) - 1);
        }

        private static int Mod(int x, int m)
        {
            var a = x % m;
            return a < 0 ? a + m : a;
        }

        private static float Grad(int hash, float x)
        {
            var h = hash & 15;
            var grad = 1.0f + (h & 7);   // Gradient value 1.0, 2.0, ..., 8.0
            if ((h & 8) != 0) grad = -grad;         // Set a random sign for the gradient
            return (grad * x);           // Multiply the gradient with the distance
        }

        private static float Grad(int hash, float x, float y)
        {
            var h = hash & 7;      // Convert low 3 bits of hash code
            var u = h < 4 ? x : y;  // into 8 simple gradient directions,
            var v = h < 4 ? y : x;  // and compute the dot product with (x,y).
            return ((h & 1) != 0 ? -u : u) + ((h & 2) != 0 ? -2.0f * v : 2.0f * v);
        }

        private static float Grad(int hash, float x, float y, float z)
        {
            var h = hash & 15;     // Convert low 4 bits of hash code into 12 simple
            var u = h < 8 ? x : y; // gradient directions, and compute dot product.
            var v = h < 4 ? y : h == 12 || h == 14 ? x : z; // Fix repeats at h = 12 to 15
            return ((h & 1) != 0 ? -u : u) + ((h & 2) != 0 ? -v : v);
        }

        private static float Grad(int hash, float x, float y, float z, float t)
        {
            var h = hash & 31;      // Convert low 5 bits of hash code into 32 simple
            var u = h < 24 ? x : y; // gradient directions, and compute dot product.
            var v = h < 16 ? y : z;
            var w = h < 8 ? z : t;
            return ((h & 1) != 0 ? -u : u) + ((h & 2) != 0 ? -v : v) + ((h & 4) != 0 ? -w : w);
        }
    }
}

---
Script: SerializePropertyReadOnly.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\SerializePropertyReadOnly.cs)

﻿using System;
using System.Reflection;
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
#endif

[System.AttributeUsage(System.AttributeTargets.Field)]
public class SerializePropertyReadOnly : PropertyAttribute
{
    public string PropertyName { get; private set; }

    public SerializePropertyReadOnly(string propertyName)
    {
        PropertyName = propertyName;
    }
}

#if UNITY_EDITOR
[CustomPropertyDrawer(typeof(SerializePropertyReadOnly))]
public class SerializePropertyReadOnlyAttributeDrawer : PropertyDrawer
{
    private PropertyInfo propertyFieldInfo = null;

    const int rows = 2;

    public override void OnGUI(Rect position, SerializedProperty property, GUIContent label)
    {
        Rect pos1 = new Rect(position.x, position.y, position.width, position.height / rows);
        Rect pos2 = new Rect(position.x, position.y += position.height / rows, position.width, position.height / rows);

        // Show the field variable normally
        EditorGUI.PropertyField(pos1, property, label, true);

        UnityEngine.Object target = property.serializedObject.targetObject;

        // Find the property field using reflection, in order to get access to its getter/setter.
        if (propertyFieldInfo == null)
            propertyFieldInfo = target.GetType().GetProperty(((SerializePropertyReadOnly)attribute).PropertyName,
                                                 BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);

        if (propertyFieldInfo != null)
        {

            // Retrieve the value using the property getter:
            object value = propertyFieldInfo.GetValue(target, null);

            label.text = propertyFieldInfo.Name;

            GUI.enabled = false;
            value = DrawProperty(pos2, property.propertyType, propertyFieldInfo.PropertyType, value, label);
            GUI.enabled = true;
        }
        else
        {
            EditorGUI.LabelField(position, "Error: could not retrieve property.");
        }
    }

    private object DrawProperty(Rect position, SerializedPropertyType propertyType, Type type, object value, GUIContent label)
    {
        switch (propertyType)
        {
            case SerializedPropertyType.Integer:
                return EditorGUI.IntField(position, label, (int)value);
            case SerializedPropertyType.Boolean:
                return EditorGUI.Toggle(position, label, (bool)value);
            case SerializedPropertyType.Float:
                return EditorGUI.FloatField(position, label, (float)value);
            case SerializedPropertyType.String:
                return EditorGUI.TextField(position, label, (string)value);
            case SerializedPropertyType.Color:
                return EditorGUI.ColorField(position, label, (Color)value);
            case SerializedPropertyType.ObjectReference:
                return EditorGUI.ObjectField(position, label, (UnityEngine.Object)value, type, true);
            case SerializedPropertyType.ExposedReference:
                return EditorGUI.ObjectField(position, label, (UnityEngine.Object)value, type, true);
            case SerializedPropertyType.LayerMask:
                return EditorGUI.LayerField(position, label, (int)value);
            case SerializedPropertyType.Enum:
                return EditorGUI.EnumPopup(position, label, (Enum)value);
            case SerializedPropertyType.Vector2:
                return EditorGUI.Vector2Field(position, label, (Vector2)value);
            case SerializedPropertyType.Vector3:
                return EditorGUI.Vector3Field(position, label, (Vector3)value);
            case SerializedPropertyType.Vector4:
                return EditorGUI.Vector4Field(position, label, (Vector4)value);
            case SerializedPropertyType.Rect:
                return EditorGUI.RectField(position, label, (Rect)value);
            case SerializedPropertyType.AnimationCurve:
                return EditorGUI.CurveField(position, label, (AnimationCurve)value);
            case SerializedPropertyType.Bounds:
                return EditorGUI.BoundsField(position, label, (Bounds)value);
            default:
                throw new NotImplementedException("Unimplemented propertyType " + propertyType + ".");
        }
    }

    public override float GetPropertyHeight(SerializedProperty property, GUIContent label)
    {
        return (base.GetPropertyHeight(property, label) + 2) * rows;  // assuming original is one row
    }
}
#endif

---
Script: Singleton.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\Singleton.cs)

using System;
using UnityEngine;

public class Singleton<T> : MonoBehaviour where T : MonoBehaviour
{
    private static T main;

    public static T Main
    {
        get
        {
            if (main != null) return main;

            main = (T)FindObjectOfType(typeof(T));

            if (main == null)
            {
                main = new GameObject(typeof(T).Name).AddComponent<T>();
            }

            //DontDestroyOnLoad(main);
            return main;
        }
    }

}
---
Script: Consts.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\Consts.cs)

﻿using UnityEngine;
using System.Collections;

public static class Consts
{

    public const float InteractionDistance = 4f;

    public const int InteractableStaticLayer = 9;

    public const int InteractableDynamicLayer = 11;

    public const int InteractableMask = 1 << InteractableStaticLayer | 1 << InteractableDynamicLayer;

    public const int VoxelMask = 1 << 8;


    // Remember to replace TerrainManager variables for these:

    public const int ChunkSizeHorizontal = 32;

    public const int ChunkSizeVertical = 64;

    public static readonly Vector3Int ChunkSize = new Vector3Int(ChunkSizeHorizontal, ChunkSizeVertical, ChunkSizeHorizontal);

    public static readonly Vector2Int ChunkSpawnSize = new Vector2Int(2, 1);

    public static readonly Vector2Int ChunkKeepSize = new Vector2Int(3, 2);

    public const int MaxGenerateChunksInFrame = 1;

    public const int MaxSaveChunksInFrame = 5;
}

---
Script: GameController.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\GameController.cs)

﻿using UnityEngine;
using System.Collections;

public static class GameController
{

    public const string gameVersion = "0.1.0";

    public static bool IsPaused { get => isPaused; set => isPaused = value; }
    public static bool isPaused;

    //public const int chunkSize = 24;

    //public static int drawRadius = 4; // Mesured in chunks!

    //public static int totalChunks = 129; // Total number of chunks in a sphere of radius drawRadius

}

---
Script: GameEvents.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\GameEvents.cs)

﻿using UnityEngine;
using System.Collections;

public delegate void EmptyDel();

public static class GameEvents
{
    //public static event EmptyDel OnLoadEnd;
}

---
Script: FastPriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\FastPriorityQueue.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Priority_Queue
{
    /// <summary>
    /// An implementation of a min-Priority Queue using a heap.  Has O(1) .Contains()!
    /// See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
    /// </summary>
    /// <typeparam name="T">The values in the queue.  Must extend the FastPriorityQueueNode class</typeparam>
    public sealed class FastPriorityQueue<T> : IFixedSizePriorityQueue<T, float>
        where T : FastPriorityQueueNode
    {
        private int _numNodes;
        private T[] _nodes;

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        public FastPriorityQueue(int maxNodes)
        {
#if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("New queue size cannot be smaller than 1");
            }
#endif

            _numNodes = 0;
            _nodes = new T[maxNodes + 1];
        }

        /// <summary>
        /// Returns the number of nodes in the queue.
        /// O(1)
        /// </summary>
        public int Count
        {
            get
            {
                return _numNodes;
            }
        }

        /// <summary>
        /// Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
        /// attempting to enqueue another item will cause undefined behavior.  O(1)
        /// </summary>
        public int MaxSize
        {
            get
            {
                return _nodes.Length - 1;
            }
        }

        /// <summary>
        /// Removes every node from the queue.
        /// O(n) (So, don't do this often!)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Clear()
        {
            Array.Clear(_nodes, 1, _numNodes);
            _numNodes = 0;
        }

        /// <summary>
        /// Returns (in O(1)!) whether the given node is in the queue.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(1)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public bool Contains(T node)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Contains was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if(node.QueueIndex < 0 || node.QueueIndex >= _nodes.Length)
            {
                throw new InvalidOperationException("node.QueueIndex has been corrupted. Did you change it manually? Or add this node to another queue?");
            }
#endif

            return (_nodes[node.QueueIndex] == node);
        }

        /// <summary>
        /// Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken arbitrarily.
        /// If the queue is full, the result is undefined.
        /// If the node is already enqueued, the result is undefined.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Enqueue(T node, float priority)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if(_numNodes >= _nodes.Length - 1)
            {
                throw new InvalidOperationException("Queue is full - node cannot be added: " + node);
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Enqueue was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("Node is already enqueued: " + node);
            }
            node.Queue = this;
#endif

            node.Priority = priority;
            _numNodes++;
            _nodes[_numNodes] = node;
            node.QueueIndex = _numNodes;
            CascadeUp(node);
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void CascadeUp(T node)
        {
            //aka Heapify-up
            int parent;
            if(node.QueueIndex > 1)
            {
                parent = node.QueueIndex >> 1;
                T parentNode = _nodes[parent];
                if(HasHigherOrEqualPriority(parentNode, node))
                    return;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            else
            {
                return;
            }
            while(parent > 1)
            {
                parent >>= 1;
                T parentNode = _nodes[parent];
                if(HasHigherOrEqualPriority(parentNode, node))
                    break;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            _nodes[node.QueueIndex] = node;
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void CascadeDown(T node)
        {
            //aka Heapify-down
            int finalQueueIndex = node.QueueIndex;
            int childLeftIndex = 2 * finalQueueIndex;

            // If leaf node, we're done
            if(childLeftIndex > _numNodes)
            {
                return;
            }

            // Check if the left-child is higher-priority than the current node
            int childRightIndex = childLeftIndex + 1;
            T childLeft = _nodes[childLeftIndex];
            if(HasHigherPriority(childLeft, node))
            {
                // Check if there is a right child. If not, swap and finish.
                if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = childLeftIndex;
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    _nodes[childLeftIndex] = node;
                    return;
                }
                // Check if the left-child is higher-priority than the right-child
                T childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childLeft, childRight))
                {
                    // left is highest, move it up and continue
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    finalQueueIndex = childLeftIndex;
                }
                else
                {
                    // right is even higher, move it up and continue
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
            }
            // Not swapping with left-child, does right-child exist?
            else if(childRightIndex > _numNodes)
            {
                return;
            }
            else
            {
                // Check if the right-child is higher-priority than the current node
                T childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childRight, node))
                {
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
                // Neither child is higher-priority than current, so finish and stop.
                else
                {
                    return;
                }
            }

            while(true)
            {
                childLeftIndex = 2 * finalQueueIndex;

                // If leaf node, we're done
                if(childLeftIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }

                // Check if the left-child is higher-priority than the current node
                childRightIndex = childLeftIndex + 1;
                childLeft = _nodes[childLeftIndex];
                if(HasHigherPriority(childLeft, node))
                {
                    // Check if there is a right child. If not, swap and finish.
                    if(childRightIndex > _numNodes)
                    {
                        node.QueueIndex = childLeftIndex;
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        _nodes[childLeftIndex] = node;
                        break;
                    }
                    // Check if the left-child is higher-priority than the right-child
                    T childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childLeft, childRight))
                    {
                        // left is highest, move it up and continue
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        finalQueueIndex = childLeftIndex;
                    }
                    else
                    {
                        // right is even higher, move it up and continue
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                }
                // Not swapping with left-child, does right-child exist?
                else if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }
                else
                {
                    // Check if the right-child is higher-priority than the current node
                    T childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childRight, node))
                    {
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                    // Neither child is higher-priority than current, so finish and stop.
                    else
                    {
                        node.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = node;
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Returns true if 'higher' has higher priority than 'lower', false otherwise.
        /// Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private bool HasHigherPriority(T higher, T lower)
        {
            return (higher.Priority < lower.Priority);
        }

        /// <summary>
        /// Returns true if 'higher' has higher priority than 'lower', false otherwise.
        /// Note that calling HasHigherOrEqualPriority(node, node) (ie. both arguments the same node) will return true
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private bool HasHigherOrEqualPriority(T higher, T lower)
        {
            return (higher.Priority <= lower.Priority);
        }

        /// <summary>
        /// Removes the head of the queue and returns it.
        /// If queue is empty, result is undefined
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public T Dequeue()
        {
#if DEBUG
            if(_numNodes <= 0)
            {
                throw new InvalidOperationException("Cannot call Dequeue() on an empty queue");
            }

            if(!IsValidQueue())
            {
                throw new InvalidOperationException("Queue has been corrupted (Did you update a node priority manually instead of calling UpdatePriority()?" +
                                                    "Or add the same node to two different queues?)");
            }
#endif

            T returnMe = _nodes[1];
            //If the node is already the last node, we can remove it immediately
            if(_numNodes == 1)
            {
                _nodes[1] = null;
                _numNodes = 0;
                return returnMe;
            }

            //Swap the node with the last node
            T formerLastNode = _nodes[_numNodes];
            _nodes[1] = formerLastNode;
            formerLastNode.QueueIndex = 1;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) down
            CascadeDown(formerLastNode);
            return returnMe;
        }

        /// <summary>
        /// Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
        /// Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
        /// O(n)
        /// </summary>
        public void Resize(int maxNodes)
        {
#if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("Queue size cannot be smaller than 1");
            }

            if (maxNodes < _numNodes)
            {
                throw new InvalidOperationException("Called Resize(" + maxNodes + "), but current queue contains " + _numNodes + " nodes");
            }
#endif

            T[] newArray = new T[maxNodes + 1];
            int highestIndexToCopy = Math.Min(maxNodes, _numNodes);
            Array.Copy(_nodes, newArray, highestIndexToCopy + 1);
            _nodes = newArray;
        }

        /// <summary>
        /// Returns the head of the queue, without removing it (use Dequeue() for that).
        /// If the queue is empty, behavior is undefined.
        /// O(1)
        /// </summary>
        public T First
        {
            get
            {
#if DEBUG
                if(_numNodes <= 0)
                {
                    throw new InvalidOperationException("Cannot call .First on an empty queue");
                }
#endif

                return _nodes[1];
            }
        }

        /// <summary>
        /// This method must be called on a node every time its priority changes while it is in the queue.  
        /// <b>Forgetting to call this method will result in a corrupted queue!</b>
        /// Calling this method on a node not in the queue results in undefined behavior
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void UpdatePriority(T node, float priority)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.UpdatePriority was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call UpdatePriority() on a node which is not enqueued: " + node);
            }
#endif

            node.Priority = priority;
            OnNodeUpdated(node);
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void OnNodeUpdated(T node)
        {
            //Bubble the updated node up or down as appropriate
            int parentIndex = node.QueueIndex >> 1;

            if(parentIndex > 0 && HasHigherPriority(node, _nodes[parentIndex]))
            {
                CascadeUp(node);
            }
            else
            {
                //Note that CascadeDown will be called if parentNode == node (that is, node is the root)
                CascadeDown(node);
            }
        }

        /// <summary>
        /// Removes a node from the queue.  The node does not need to be the head of the queue.  
        /// If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Remove(T node)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Remove was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call Remove() on a node which is not enqueued: " + node);
            }
#endif

            //If the node is already the last node, we can remove it immediately
            if(node.QueueIndex == _numNodes)
            {
                _nodes[_numNodes] = null;
                _numNodes--;
                return;
            }

            //Swap the node with the last node
            T formerLastNode = _nodes[_numNodes];
            _nodes[node.QueueIndex] = formerLastNode;
            formerLastNode.QueueIndex = node.QueueIndex;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) up or down as appropriate
            OnNodeUpdated(formerLastNode);
        }

        /// <summary>
        /// By default, nodes that have been previously added to one queue cannot be added to another queue.
        /// If you need to do this, please call originalQueue.ResetNode(node) before attempting to add it in the new queue
        /// If the node is currently in the queue or belongs to another queue, the result is undefined
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void ResetNode(T node)
        {
#if DEBUG
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node from another queue");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node that is still in the queue");
            }

            node.Queue = null;
#endif

            node.QueueIndex = 0;
        }

        public IEnumerator<T> GetEnumerator()
        {
#if NET_VERSION_4_5 // ArraySegment does not implement IEnumerable before 4.5
            IEnumerable<T> e = new ArraySegment<T>(_nodes, 1, _numNodes);
            return e.GetEnumerator();
#else
            for(int i = 1; i <= _numNodes; i++)
                yield return _nodes[i];
#endif
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// <b>Should not be called in production code.</b>
        /// Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
        /// </summary>
        public bool IsValidQueue()
        {
            for(int i = 1; i < _nodes.Length; i++)
            {
                if(_nodes[i] != null)
                {
                    int childLeftIndex = 2 * i;
                    if(childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex], _nodes[i]))
                        return false;

                    int childRightIndex = childLeftIndex + 1;
                    if(childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex], _nodes[i]))
                        return false;
                }
            }
            return true;
        }
    }
}
---
Script: FastPriorityQueueNode.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\FastPriorityQueueNode.cs)

﻿using System;

namespace Priority_Queue
{
    public class FastPriorityQueueNode
    {
        /// <summary>
        /// The Priority to insert this node at.  Must be set BEFORE adding a node to the queue (ideally just once, in the node's constructor).
        /// Should not be manually edited once the node has been enqueued - use queue.UpdatePriority() instead
        /// </summary>
        public float Priority { get; protected internal set; }

        /// <summary>
        /// Represents the current position in the queue
        /// </summary>
        public int QueueIndex { get; internal set; }

#if DEBUG
        /// <summary>
        /// The queue this node is tied to. Used only for debug builds.
        /// </summary>
        public object Queue { get; internal set; }
#endif
    }
}

---
Script: GenericPriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\GenericPriorityQueue.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Priority_Queue
{
    /// <summary>
    /// A copy of StablePriorityQueue which also has generic priority-type
    /// </summary>
    /// <typeparam name="TItem">The values in the queue.  Must extend the GenericPriorityQueueNode class</typeparam>
    /// <typeparam name="TPriority">The priority-type.  Must extend IComparable&lt;TPriority&gt;</typeparam>
    public sealed class GenericPriorityQueue<TItem, TPriority> : IFixedSizePriorityQueue<TItem, TPriority>
        where TItem : GenericPriorityQueueNode<TPriority>
        where TPriority : IComparable<TPriority>
    {
        private int _numNodes;
        private TItem[] _nodes;
        private long _numNodesEverEnqueued;
        private readonly Comparison<TPriority> _comparer;

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        public GenericPriorityQueue(int maxNodes) : this(maxNodes, Comparer<TPriority>.Default) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        /// <param name="comparer">The comparer used to compare TPriority values.</param>
        public GenericPriorityQueue(int maxNodes, IComparer<TPriority> comparer) : this(maxNodes, comparer.Compare) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        /// <param name="comparer">The comparison function to use to compare TPriority values</param>
        public GenericPriorityQueue(int maxNodes, Comparison<TPriority> comparer)
        {
#if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("New queue size cannot be smaller than 1");
            }
#endif

            _numNodes = 0;
            _nodes = new TItem[maxNodes + 1];
            _numNodesEverEnqueued = 0;
            _comparer = comparer;
        }

        /// <summary>
        /// Returns the number of nodes in the queue.
        /// O(1)
        /// </summary>
        public int Count
        {
            get
            {
                return _numNodes;
            }
        }

        /// <summary>
        /// Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
        /// attempting to enqueue another item will cause undefined behavior.  O(1)
        /// </summary>
        public int MaxSize
        {
            get
            {
                return _nodes.Length - 1;
            }
        }

        /// <summary>
        /// Removes every node from the queue.
        /// O(n) (So, don't do this often!)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Clear()
        {
            Array.Clear(_nodes, 1, _numNodes);
            _numNodes = 0;
        }

        /// <summary>
        /// Returns (in O(1)!) whether the given node is in the queue.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(1)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public bool Contains(TItem node)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Contains was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if (node.QueueIndex < 0 || node.QueueIndex >= _nodes.Length)
            {
                throw new InvalidOperationException("node.QueueIndex has been corrupted. Did you change it manually?");
            }
#endif

            return (_nodes[node.QueueIndex] == node);
        }

        /// <summary>
        /// Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
        /// If the queue is full, the result is undefined.
        /// If the node is already enqueued, the result is undefined.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Enqueue(TItem node, TPriority priority)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if(_numNodes >= _nodes.Length - 1)
            {
                throw new InvalidOperationException("Queue is full - node cannot be added: " + node);
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Enqueue was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("Node is already enqueued: " + node);
            }
            node.Queue = this;
#endif

            node.Priority = priority;
            _numNodes++;
            _nodes[_numNodes] = node;
            node.QueueIndex = _numNodes;
            node.InsertionIndex = _numNodesEverEnqueued++;
            CascadeUp(node);
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void CascadeUp(TItem node)
        {
            //aka Heapify-up
            int parent;
            if (node.QueueIndex > 1)
            {
                parent = node.QueueIndex >> 1;
                TItem parentNode = _nodes[parent];
                if(HasHigherPriority(parentNode, node))
                    return;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            else
            {
                return;
            }
            while(parent > 1)
            {
                parent >>= 1;
                TItem parentNode = _nodes[parent];
                if(HasHigherPriority(parentNode, node))
                    break;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            _nodes[node.QueueIndex] = node;
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void CascadeDown(TItem node)
        {
            //aka Heapify-down
            int finalQueueIndex = node.QueueIndex;
            int childLeftIndex = 2 * finalQueueIndex;

            // If leaf node, we're done
            if(childLeftIndex > _numNodes)
            {
                return;
            }

            // Check if the left-child is higher-priority than the current node
            int childRightIndex = childLeftIndex + 1;
            TItem childLeft = _nodes[childLeftIndex];
            if(HasHigherPriority(childLeft, node))
            {
                // Check if there is a right child. If not, swap and finish.
                if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = childLeftIndex;
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    _nodes[childLeftIndex] = node;
                    return;
                }
                // Check if the left-child is higher-priority than the right-child
                TItem childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childLeft, childRight))
                {
                    // left is highest, move it up and continue
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    finalQueueIndex = childLeftIndex;
                }
                else
                {
                    // right is even higher, move it up and continue
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
            }
            // Not swapping with left-child, does right-child exist?
            else if(childRightIndex > _numNodes)
            {
                return;
            }
            else
            {
                // Check if the right-child is higher-priority than the current node
                TItem childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childRight, node))
                {
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
                // Neither child is higher-priority than current, so finish and stop.
                else
                {
                    return;
                }
            }

            while(true)
            {
                childLeftIndex = 2 * finalQueueIndex;

                // If leaf node, we're done
                if(childLeftIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }

                // Check if the left-child is higher-priority than the current node
                childRightIndex = childLeftIndex + 1;
                childLeft = _nodes[childLeftIndex];
                if(HasHigherPriority(childLeft, node))
                {
                    // Check if there is a right child. If not, swap and finish.
                    if(childRightIndex > _numNodes)
                    {
                        node.QueueIndex = childLeftIndex;
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        _nodes[childLeftIndex] = node;
                        break;
                    }
                    // Check if the left-child is higher-priority than the right-child
                    TItem childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childLeft, childRight))
                    {
                        // left is highest, move it up and continue
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        finalQueueIndex = childLeftIndex;
                    }
                    else
                    {
                        // right is even higher, move it up and continue
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                }
                // Not swapping with left-child, does right-child exist?
                else if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }
                else
                {
                    // Check if the right-child is higher-priority than the current node
                    TItem childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childRight, node))
                    {
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                    // Neither child is higher-priority than current, so finish and stop.
                    else
                    {
                        node.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = node;
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Returns true if 'higher' has higher priority than 'lower', false otherwise.
        /// Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private bool HasHigherPriority(TItem higher, TItem lower)
        {
            var cmp = _comparer(higher.Priority, lower.Priority);
            return (cmp < 0 || (cmp == 0 && higher.InsertionIndex < lower.InsertionIndex));
        }

        /// <summary>
        /// Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
        /// If queue is empty, result is undefined
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public TItem Dequeue()
        {
#if DEBUG
            if(_numNodes <= 0)
            {
                throw new InvalidOperationException("Cannot call Dequeue() on an empty queue");
            }

            if(!IsValidQueue())
            {
                throw new InvalidOperationException("Queue has been corrupted (Did you update a node priority manually instead of calling UpdatePriority()?" +
                                                    "Or add the same node to two different queues?)");
            }
#endif

            TItem returnMe = _nodes[1];
            //If the node is already the last node, we can remove it immediately
            if(_numNodes == 1)
            {
                _nodes[1] = null;
                _numNodes = 0;
                return returnMe;
            }

            //Swap the node with the last node
            TItem formerLastNode = _nodes[_numNodes];
            _nodes[1] = formerLastNode;
            formerLastNode.QueueIndex = 1;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) down
            CascadeDown(formerLastNode);
            return returnMe;
        }

        /// <summary>
        /// Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
        /// Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
        /// O(n)
        /// </summary>
        public void Resize(int maxNodes)
        {
#if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("Queue size cannot be smaller than 1");
            }

            if (maxNodes < _numNodes)
            {
                throw new InvalidOperationException("Called Resize(" + maxNodes + "), but current queue contains " + _numNodes + " nodes");
            }
#endif

            TItem[] newArray = new TItem[maxNodes + 1];
            int highestIndexToCopy = Math.Min(maxNodes, _numNodes);
            Array.Copy(_nodes, newArray, highestIndexToCopy + 1);
            _nodes = newArray;
        }

        /// <summary>
        /// Returns the head of the queue, without removing it (use Dequeue() for that).
        /// If the queue is empty, behavior is undefined.
        /// O(1)
        /// </summary>
        public TItem First
        {
            get
            {
#if DEBUG
                if(_numNodes <= 0)
                {
                    throw new InvalidOperationException("Cannot call .First on an empty queue");
                }
#endif

                return _nodes[1];
            }
        }

        /// <summary>
        /// This method must be called on a node every time its priority changes while it is in the queue.  
        /// <b>Forgetting to call this method will result in a corrupted queue!</b>
        /// Calling this method on a node not in the queue results in undefined behavior
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void UpdatePriority(TItem node, TPriority priority)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.UpdatePriority was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call UpdatePriority() on a node which is not enqueued: " + node);
            }
#endif

            node.Priority = priority;
            OnNodeUpdated(node);
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void OnNodeUpdated(TItem node)
        {
            //Bubble the updated node up or down as appropriate
            int parentIndex = node.QueueIndex >> 1;

            if(parentIndex > 0 && HasHigherPriority(node, _nodes[parentIndex]))
            {
                CascadeUp(node);
            }
            else
            {
                //Note that CascadeDown will be called if parentNode == node (that is, node is the root)
                CascadeDown(node);
            }
        }

        /// <summary>
        /// Removes a node from the queue.  The node does not need to be the head of the queue.  
        /// If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Remove(TItem node)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Remove was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call Remove() on a node which is not enqueued: " + node);
            }
#endif

            //If the node is already the last node, we can remove it immediately
            if(node.QueueIndex == _numNodes)
            {
                _nodes[_numNodes] = null;
                _numNodes--;
                return;
            }

            //Swap the node with the last node
            TItem formerLastNode = _nodes[_numNodes];
            _nodes[node.QueueIndex] = formerLastNode;
            formerLastNode.QueueIndex = node.QueueIndex;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) up or down as appropriate
            OnNodeUpdated(formerLastNode);
        }

        /// <summary>
        /// By default, nodes that have been previously added to one queue cannot be added to another queue.
        /// If you need to do this, please call originalQueue.ResetNode(node) before attempting to add it in the new queue
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void ResetNode(TItem node)
        {
#if DEBUG
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node from another queue");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node that is still in the queue");
            }

            node.Queue = null;
#endif

            node.QueueIndex = 0;
        }


        public IEnumerator<TItem> GetEnumerator()
        {
#if NET_VERSION_4_5 // ArraySegment does not implement IEnumerable before 4.5
            IEnumerable<TItem> e = new ArraySegment<TItem>(_nodes, 1, _numNodes);
            return e.GetEnumerator();
#else
            for(int i = 1; i <= _numNodes; i++)
                yield return _nodes[i];
#endif
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// <b>Should not be called in production code.</b>
        /// Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
        /// </summary>
        public bool IsValidQueue()
        {
            for(int i = 1; i < _nodes.Length; i++)
            {
                if(_nodes[i] != null)
                {
                    int childLeftIndex = 2 * i;
                    if(childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex], _nodes[i]))
                        return false;

                    int childRightIndex = childLeftIndex + 1;
                    if(childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex], _nodes[i]))
                        return false;
                }
            }
            return true;
        }
    }
}

---
Script: GenericPriorityQueueNode.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\GenericPriorityQueueNode.cs)

﻿namespace Priority_Queue
{
    public class GenericPriorityQueueNode<TPriority>
    {
        /// <summary>
        /// The Priority to insert this node at.  Must be set BEFORE adding a node to the queue (ideally just once, in the node's constructor).
        /// Should not be manually edited once the node has been enqueued - use queue.UpdatePriority() instead
        /// </summary>
        public TPriority Priority { get; protected internal set; }

        /// <summary>
        /// Represents the current position in the queue
        /// </summary>
        public int QueueIndex { get; internal set; }

        /// <summary>
        /// Represents the order the node was inserted in
        /// </summary>
        public long InsertionIndex { get; internal set; }


#if DEBUG
        /// <summary>
        /// The queue this node is tied to. Used only for debug builds.
        /// </summary>
        public object Queue { get; internal set; }
#endif
    }
}

---
Script: IFixedSizePriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\IFixedSizePriorityQueue.cs)

﻿using System;
using System.Collections.Generic;
using System.Text;

namespace Priority_Queue
{
    /// <summary>
    /// A helper-interface only needed to make writing unit tests a bit easier (hence the 'internal' access modifier)
    /// </summary>
    internal interface IFixedSizePriorityQueue<TItem, in TPriority> : IPriorityQueue<TItem, TPriority>
        where TPriority : IComparable<TPriority>
    {
        /// <summary>
        /// Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
        /// Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
        /// </summary>
        void Resize(int maxNodes);

        /// <summary>
        /// Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
        /// attempting to enqueue another item will cause undefined behavior.
        /// </summary>
        int MaxSize { get; }

        /// <summary>
        /// By default, nodes that have been previously added to one queue cannot be added to another queue.
        /// If you need to do this, please call originalQueue.ResetNode(node) before attempting to add it in the new queue
        /// </summary>
        void ResetNode(TItem node);
    }
}

---
Script: IPriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\IPriorityQueue.cs)

﻿using System;
using System.Collections.Generic;

namespace Priority_Queue
{
    /// <summary>
    /// The IPriorityQueue interface.  This is mainly here for purists, and in case I decide to add more implementations later.
    /// For speed purposes, it is actually recommended that you *don't* access the priority queue through this interface, since the JIT can
    /// (theoretically?) optimize method calls from concrete-types slightly better.
    /// </summary>
    public interface IPriorityQueue<TItem, in TPriority> : IEnumerable<TItem>
        where TPriority : IComparable<TPriority>
    {
        /// <summary>
        /// Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
        /// See implementation for how duplicates are handled.
        /// </summary>
        void Enqueue(TItem node, TPriority priority);

        /// <summary>
        /// Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
        /// </summary>
        TItem Dequeue();

        /// <summary>
        /// Removes every node from the queue.
        /// </summary>
        void Clear();

        /// <summary>
        /// Returns whether the given node is in the queue.
        /// </summary>
        bool Contains(TItem node);

        /// <summary>
        /// Removes a node from the queue.  The node does not need to be the head of the queue.  
        /// </summary>
        void Remove(TItem node);

        /// <summary>
        /// Call this method to change the priority of a node.  
        /// </summary>
        void UpdatePriority(TItem node, TPriority priority);

        /// <summary>
        /// Returns the head of the queue, without removing it (use Dequeue() for that).
        /// </summary>
        TItem First { get; }

        /// <summary>
        /// Returns the number of nodes in the queue.
        /// </summary>
        int Count { get; }
    }
}

---
Script: SimplePriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\SimplePriorityQueue.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;

namespace Priority_Queue
{
    /// <summary>
    /// A simplified priority queue implementation.  Is stable, auto-resizes, and thread-safe, at the cost of being slightly slower than
    /// FastPriorityQueue
    /// Methods tagged as O(1) or O(log n) are assuming there are no duplicates.  Duplicates may increase the algorithmic complexity.
    /// </summary>
    /// <typeparam name="TItem">The type to enqueue</typeparam>
    /// <typeparam name="TPriority">The priority-type to use for nodes.  Must extend IComparable&lt;TPriority&gt;</typeparam>
    public class SimplePriorityQueue<TItem, TPriority> : IPriorityQueue<TItem, TPriority>
        where TPriority : IComparable<TPriority>
    {
        private class SimpleNode : GenericPriorityQueueNode<TPriority>
        {
            public TItem Data { get; private set; }

            public SimpleNode(TItem data)
            {
                Data = data;
            }
        }

        private const int INITIAL_QUEUE_SIZE = 100;
        private readonly GenericPriorityQueue<SimpleNode, TPriority> _queue;
        private readonly Dictionary<TItem, IList<SimpleNode>> _itemToNodesCache;
        private readonly IList<SimpleNode> _nullNodesCache;

        #region Constructors
        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        public SimplePriorityQueue() : this(Comparer<TPriority>.Default, EqualityComparer<TItem>.Default) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="priorityComparer">The comparer used to compare TPriority values.  Defaults to Comparer&lt;TPriority&gt;.default</param>
        public SimplePriorityQueue(IComparer<TPriority> priorityComparer) : this(priorityComparer.Compare, EqualityComparer<TItem>.Default) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="priorityComparer">The comparison function to use to compare TPriority values</param>
        public SimplePriorityQueue(Comparison<TPriority> priorityComparer) : this(priorityComparer, EqualityComparer<TItem>.Default) { }

        /// <summary>
        /// Instantiate a new Priority Queue       
        /// </summary>
        /// <param name="itemEquality">The equality comparison function to use to compare TItem values</param>
        public SimplePriorityQueue(IEqualityComparer<TItem> itemEquality) : this(Comparer<TPriority>.Default, itemEquality) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="priorityComparer">The comparer used to compare TPriority values.  Defaults to Comparer&lt;TPriority&gt;.default</param>
        /// <param name="itemEquality">The equality comparison function to use to compare TItem values</param>
        public SimplePriorityQueue(IComparer<TPriority> priorityComparer, IEqualityComparer<TItem> itemEquality) : this(priorityComparer.Compare, itemEquality) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="priorityComparer">The comparison function to use to compare TPriority values</param>
        /// <param name="itemEquality">The equality comparison function to use to compare TItem values</param>
        public SimplePriorityQueue(Comparison<TPriority> priorityComparer, IEqualityComparer<TItem> itemEquality)
        {
            _queue = new GenericPriorityQueue<SimpleNode, TPriority>(INITIAL_QUEUE_SIZE, priorityComparer);
            _itemToNodesCache = new Dictionary<TItem, IList<SimpleNode>>(itemEquality);
            _nullNodesCache = new List<SimpleNode>();
        }
        #endregion

        /// <summary>
        /// Given an item of type T, returns the existing SimpleNode in the queue
        /// </summary>
        private SimpleNode GetExistingNode(TItem item)
        {
            if (item == null)
            {
                return _nullNodesCache.Count > 0 ? _nullNodesCache[0] : null;
            }

            IList<SimpleNode> nodes;
            if (!_itemToNodesCache.TryGetValue(item, out nodes))
            {
                return null;
            }
            return nodes[0];
        }

        /// <summary>
        /// Adds an item to the Node-cache to allow for many methods to be O(1) or O(log n)
        /// </summary>
        private void AddToNodeCache(SimpleNode node)
        {
            if (node.Data == null)
            {
                _nullNodesCache.Add(node);
                return;
            }

            IList<SimpleNode> nodes;
            if (!_itemToNodesCache.TryGetValue(node.Data, out nodes))
            {
                nodes = new List<SimpleNode>();
                _itemToNodesCache[node.Data] = nodes;
            }
            nodes.Add(node);
        }

        /// <summary>
        /// Removes an item to the Node-cache to allow for many methods to be O(1) or O(log n) (assuming no duplicates)
        /// </summary>
        private void RemoveFromNodeCache(SimpleNode node)
        {
            if (node.Data == null)
            {
                _nullNodesCache.Remove(node);
                return;
            }

            IList<SimpleNode> nodes;
            if (!_itemToNodesCache.TryGetValue(node.Data, out nodes))
            {
                return;
            }
            nodes.Remove(node);
            if (nodes.Count == 0)
            {
                _itemToNodesCache.Remove(node.Data);
            }
        }

        /// <summary>
        /// Returns the number of nodes in the queue.
        /// O(1)
        /// </summary>
        public int Count
        {
            get
            {
                lock(_queue)
                {
                    return _queue.Count;
                }
            }
        }

        /// <summary>
        /// Returns the head of the queue, without removing it (use Dequeue() for that).
        /// Throws an exception when the queue is empty.
        /// O(1)
        /// </summary>
        public TItem First
        {
            get
            {
                lock(_queue)
                {
                    if(_queue.Count <= 0)
                    {
                        throw new InvalidOperationException("Cannot call .First on an empty queue");
                    }

                    return _queue.First.Data;
                }
            }
        }

        /// <summary>
        /// Removes every node from the queue.
        /// O(n)
        /// </summary>
        public void Clear()
        {
            lock(_queue)
            {
                _queue.Clear();
                _itemToNodesCache.Clear();
                _nullNodesCache.Clear();
            }
        }

        /// <summary>
        /// Returns whether the given item is in the queue.
        /// O(1)
        /// </summary>
        public bool Contains(TItem item)
        {
            lock(_queue)
            {
                return item == null ? _nullNodesCache.Count > 0 : _itemToNodesCache.ContainsKey(item);
            }
        }

        /// <summary>
        /// Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
        /// If queue is empty, throws an exception
        /// O(log n)
        /// </summary>
        public TItem Dequeue()
        {
            lock(_queue)
            {
                if(_queue.Count <= 0)
                {
                    throw new InvalidOperationException("Cannot call Dequeue() on an empty queue");
                }

                SimpleNode node =_queue.Dequeue();
                RemoveFromNodeCache(node);
                return node.Data;
            }
        }

        /// <summary>
        /// Enqueue the item with the given priority, without calling lock(_queue) or AddToNodeCache(node)
        /// </summary>
        /// <param name="item"></param>
        /// <param name="priority"></param>
        /// <returns></returns>
        private SimpleNode EnqueueNoLockOrCache(TItem item, TPriority priority)
        {
            SimpleNode node = new SimpleNode(item);
            if (_queue.Count == _queue.MaxSize)
            {
                _queue.Resize(_queue.MaxSize * 2 + 1);
            }
            _queue.Enqueue(node, priority);
            return node;
        }

        /// <summary>
        /// Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
        /// This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.
        /// Duplicates and null-values are allowed.
        /// O(log n)
        /// </summary>
        public void Enqueue(TItem item, TPriority priority)
        {
            lock(_queue)
            {
                IList<SimpleNode> nodes;
                if (item == null)
                {
                    nodes = _nullNodesCache;
                }
                else if (!_itemToNodesCache.TryGetValue(item, out nodes))
                {
                    nodes = new List<SimpleNode>();
                    _itemToNodesCache[item] = nodes;
                }
                SimpleNode node = EnqueueNoLockOrCache(item, priority);
                nodes.Add(node);
            }
        }

        /// <summary>
        /// Enqueue a node to the priority queue if it doesn't already exist.  Lower values are placed in front. Ties are broken by first-in-first-out.
        /// This queue automatically resizes itself, so there's no concern of the queue becoming 'full'.  Null values are allowed.
        /// Returns true if the node was successfully enqueued; false if it already exists.
        /// O(log n)
        /// </summary>
        public bool EnqueueWithoutDuplicates(TItem item, TPriority priority)
        {
            lock(_queue)
            {
                IList<SimpleNode> nodes;
                if (item == null)
                {
                    if (_nullNodesCache.Count > 0)
                    {
                        return false;
                    }
                    nodes = _nullNodesCache;
                }
                else if (_itemToNodesCache.ContainsKey(item))
                {
                    return false;
                }
                else
                {
                    nodes = new List<SimpleNode>();
                    _itemToNodesCache[item] = nodes;
                }
                SimpleNode node = EnqueueNoLockOrCache(item, priority);
                nodes.Add(node);
                return true;
            }
        }

        /// <summary>
        /// Removes an item from the queue.  The item does not need to be the head of the queue.  
        /// If the item is not in the queue, an exception is thrown.  If unsure, check Contains() first.
        /// If multiple copies of the item are enqueued, only the first one is removed. 
        /// O(log n)
        /// </summary>
        public void Remove(TItem item)
        {
            lock(_queue)
            {
                SimpleNode removeMe;
                IList<SimpleNode> nodes;
                if (item == null)
                {
                    if (_nullNodesCache.Count == 0)
                    {
                        throw new InvalidOperationException("Cannot call Remove() on a node which is not enqueued: " + item);
                    }
                    removeMe = _nullNodesCache[0];
                    nodes = _nullNodesCache;
                }
                else
                {
                    if (!_itemToNodesCache.TryGetValue(item, out nodes))
                    {
                        throw new InvalidOperationException("Cannot call Remove() on a node which is not enqueued: " + item);
                    }
                    removeMe = nodes[0];
                    if (nodes.Count == 1)
                    {
                        _itemToNodesCache.Remove(item);
                    }
                }
                _queue.Remove(removeMe);
                nodes.Remove(removeMe);
            }
        }

        /// <summary>
        /// Call this method to change the priority of an item.
        /// Calling this method on a item not in the queue will throw an exception.
        /// If the item is enqueued multiple times, only the first one will be updated.
        /// (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
        /// to update all of them, please wrap your items in a wrapper class so they can be distinguished).
        /// O(log n)
        /// </summary>
        public void UpdatePriority(TItem item, TPriority priority)
        {
            lock (_queue)
            {
                SimpleNode updateMe = GetExistingNode(item);
                if (updateMe == null)
                {
                    throw new InvalidOperationException("Cannot call UpdatePriority() on a node which is not enqueued: " + item);
                }
                _queue.UpdatePriority(updateMe, priority);
            }
        }

        /// <summary>
        /// Returns the priority of the given item.
        /// Calling this method on a item not in the queue will throw an exception.
        /// If the item is enqueued multiple times, only the priority of the first will be returned.
        /// (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
        /// to query all their priorities, please wrap your items in a wrapper class so they can be distinguished).
        /// O(1)
        /// </summary>
        public TPriority GetPriority(TItem item)
        {
            lock (_queue)
            {
                SimpleNode findMe = GetExistingNode(item);
                if(findMe == null)
                {
                    throw new InvalidOperationException("Cannot call GetPriority() on a node which is not enqueued: " + item);
                }
                return findMe.Priority;
            }
        }

        #region Try* methods for multithreading
        /// Get the head of the queue, without removing it (use TryDequeue() for that).
        /// Useful for multi-threading, where the queue may become empty between calls to Contains() and First
        /// Returns true if successful, false otherwise
        /// O(1)
        public bool TryFirst(out TItem first)
        {
            if (_queue.Count > 0)
            {
                lock (_queue)
                {
                    if (_queue.Count > 0)
                    {
                        first = _queue.First.Data;
                        return true;
                    }
                }
            }

            first = default(TItem);
            return false;
        }

        /// <summary>
        /// Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and sets it to first.
        /// Useful for multi-threading, where the queue may become empty between calls to Contains() and Dequeue()
        /// Returns true if successful; false if queue was empty
        /// O(log n)
        /// </summary>
        public bool TryDequeue(out TItem first)
        {
            if (_queue.Count > 0)
            {
                lock (_queue)
                {
                    if (_queue.Count > 0)
                    {
                        SimpleNode node = _queue.Dequeue();
                        first = node.Data;
                        RemoveFromNodeCache(node);
                        return true;
                    }
                }
            }
            
            first = default(TItem);
            return false;
        }

        /// <summary>
        /// Attempts to remove an item from the queue.  The item does not need to be the head of the queue.  
        /// Useful for multi-threading, where the queue may become empty between calls to Contains() and Remove()
        /// Returns true if the item was successfully removed, false if it wasn't in the queue.
        /// If multiple copies of the item are enqueued, only the first one is removed. 
        /// O(log n)
        /// </summary>
        public bool TryRemove(TItem item)
        {
            lock(_queue)
            {
                SimpleNode removeMe;
                IList<SimpleNode> nodes;
                if (item == null)
                {
                    if (_nullNodesCache.Count == 0)
                    {
                        return false;
                    }
                    removeMe = _nullNodesCache[0];
                    nodes = _nullNodesCache;
                }
                else
                {
                    if (!_itemToNodesCache.TryGetValue(item, out nodes))
                    {
                        return false;
                    }
                    removeMe = nodes[0];
                    if (nodes.Count == 1)
                    {
                        _itemToNodesCache.Remove(item);
                    }
                }
                _queue.Remove(removeMe);
                nodes.Remove(removeMe);
                return true;
            }
        }

        /// <summary>
        /// Call this method to change the priority of an item.
        /// Useful for multi-threading, where the queue may become empty between calls to Contains() and UpdatePriority()
        /// If the item is enqueued multiple times, only the first one will be updated.
        /// (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
        /// to update all of them, please wrap your items in a wrapper class so they can be distinguished).
        /// Returns true if the item priority was updated, false otherwise.
        /// O(log n)
        /// </summary>
        public bool TryUpdatePriority(TItem item, TPriority priority)
        {
            lock(_queue)
            {
                SimpleNode updateMe = GetExistingNode(item);
                if(updateMe == null)
                {
                    return false;
                }
                _queue.UpdatePriority(updateMe, priority);
                return true;
            }
        }

        /// <summary>
        /// Attempt to get the priority of the given item.
        /// Useful for multi-threading, where the queue may become empty between calls to Contains() and GetPriority()
        /// If the item is enqueued multiple times, only the priority of the first will be returned.
        /// (If your requirements are complex enough that you need to enqueue the same item multiple times <i>and</i> be able
        /// to query all their priorities, please wrap your items in a wrapper class so they can be distinguished).
        /// Returns true if the item was found in the queue, false otherwise
        /// O(1)
        /// </summary>
        public bool TryGetPriority(TItem item, out TPriority priority)
        {
            lock(_queue)
            {
                SimpleNode findMe = GetExistingNode(item);
                if(findMe == null)
                {
                    priority = default(TPriority);
                    return false;
                }
                priority = findMe.Priority;
                return true;
            }
        }
        #endregion

        public IEnumerator<TItem> GetEnumerator()
        {
            List<TItem> queueData = new List<TItem>();
            lock (_queue)
            {
                //Copy to a separate list because we don't want to 'yield return' inside a lock
                foreach(var node in _queue)
                {
                    queueData.Add(node.Data);
                }
            }

            return queueData.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        public bool IsValidQueue()
        {
            lock(_queue)
            {
                // Check all items in cache are in the queue
                foreach (IList<SimpleNode> nodes in _itemToNodesCache.Values)
                {
                    foreach (SimpleNode node in nodes)
                    {
                        if (!_queue.Contains(node))
                        {
                            return false;
                        }
                    }
                }

                // Check all items in queue are in cache
                foreach (SimpleNode node in _queue)
                {
                    if (GetExistingNode(node.Data) == null)
                    {
                        return false;
                    }
                }

                // Check queue structure itself
                return _queue.IsValidQueue();
            }
        }
    }

    /// <summary>
    /// A simplified priority queue implementation.  Is stable, auto-resizes, and thread-safe, at the cost of being slightly slower than
    /// FastPriorityQueue
    /// This class is kept here for backwards compatibility.  It's recommended you use SimplePriorityQueue&lt;TItem, TPriority&gt;
    /// </summary>
    /// <typeparam name="TItem">The type to enqueue</typeparam>
    public class SimplePriorityQueue<TItem> : SimplePriorityQueue<TItem, float>
    {
        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        public SimplePriorityQueue() { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="comparer">The comparer used to compare priority values.  Defaults to Comparer&lt;float&gt;.default</param>
        public SimplePriorityQueue(IComparer<float> comparer) : base(comparer) { }

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="comparer">The comparison function to use to compare priority values</param>
        public SimplePriorityQueue(Comparison<float> comparer) : base(comparer) { }
    }
}
---
Script: StablePriorityQueue.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\StablePriorityQueue.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace Priority_Queue
{
    /// <summary>
    /// A copy of FastPriorityQueue which is also stable - that is, when two nodes are enqueued with the same priority, they
    /// are always dequeued in the same order.
    /// See https://github.com/BlueRaja/High-Speed-Priority-Queue-for-C-Sharp/wiki/Getting-Started for more information
    /// </summary>
    /// <typeparam name="T">The values in the queue.  Must extend the StablePriorityQueueNode class</typeparam>
    public sealed class StablePriorityQueue<T> : IFixedSizePriorityQueue<T, float>
        where T : StablePriorityQueueNode
    {
        private int _numNodes;
        private T[] _nodes;
        private long _numNodesEverEnqueued;

        /// <summary>
        /// Instantiate a new Priority Queue
        /// </summary>
        /// <param name="maxNodes">The max nodes ever allowed to be enqueued (going over this will cause undefined behavior)</param>
        public StablePriorityQueue(int maxNodes)
        {
            #if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("New queue size cannot be smaller than 1");
            }
            #endif

            _numNodes = 0;
            _nodes = new T[maxNodes + 1];
            _numNodesEverEnqueued = 0;
        }

        /// <summary>
        /// Returns the number of nodes in the queue.
        /// O(1)
        /// </summary>
        public int Count
        {
            get
            {
                return _numNodes;
            }
        }

        /// <summary>
        /// Returns the maximum number of items that can be enqueued at once in this queue.  Once you hit this number (ie. once Count == MaxSize),
        /// attempting to enqueue another item will cause undefined behavior.  O(1)
        /// </summary>
        public int MaxSize
        {
            get
            {
                return _nodes.Length - 1;
            }
        }

        /// <summary>
        /// Removes every node from the queue.
        /// O(n) (So, don't do this often!)
        /// </summary>
        #if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        public void Clear()
        {
            Array.Clear(_nodes, 1, _numNodes);
            _numNodes = 0;
        }

        /// <summary>
        /// Returns (in O(1)!) whether the given node is in the queue.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(1)
        /// </summary>
        #if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        public bool Contains(T node)
        {
            #if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Contains was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if (node.QueueIndex < 0 || node.QueueIndex >= _nodes.Length)
            {
                throw new InvalidOperationException("node.QueueIndex has been corrupted. Did you change it manually?");
            }
            #endif

            return (_nodes[node.QueueIndex] == node);
        }

        /// <summary>
        /// Enqueue a node to the priority queue.  Lower values are placed in front. Ties are broken by first-in-first-out.
        /// If the queue is full, the result is undefined.
        /// If the node is already enqueued, the result is undefined.
        /// If node is or has been previously added to another queue, the result is undefined unless oldQueue.ResetNode(node) has been called
        /// O(log n)
        /// </summary>
        #if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        public void Enqueue(T node, float priority)
        {
            #if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if(_numNodes >= _nodes.Length - 1)
            {
                throw new InvalidOperationException("Queue is full - node cannot be added: " + node);
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Enqueue was called on a node from another queue.  Please call originalQueue.ResetNode() first");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("Node is already enqueued: " + node);
            }
            node.Queue = this;
            #endif

            node.Priority = priority;
            _numNodes++;
            _nodes[_numNodes] = node;
            node.QueueIndex = _numNodes;
            node.InsertionIndex = _numNodesEverEnqueued++;
            CascadeUp(node);
        }

        //Performance appears to be slightly better when this is NOT inlined o_O
        #if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        private void CascadeUp(T node)
        {
            //aka Heapify-up
            int parent;
            if(node.QueueIndex > 1)
            {
                parent = node.QueueIndex >> 1;
                T parentNode = _nodes[parent];
                if(HasHigherPriority(parentNode, node))
                    return;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            else
            {
                return;
            }
            while(parent > 1)
            {
                parent >>= 1;
                T parentNode = _nodes[parent];
                if(HasHigherPriority(parentNode, node))
                    break;

                //Node has lower priority value, so move parent down the heap to make room
                _nodes[node.QueueIndex] = parentNode;
                parentNode.QueueIndex = node.QueueIndex;

                node.QueueIndex = parent;
            }
            _nodes[node.QueueIndex] = node;
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void CascadeDown(T node)
        {
            //aka Heapify-down
            int finalQueueIndex = node.QueueIndex;
            int childLeftIndex = 2 * finalQueueIndex;

            // If leaf node, we're done
            if(childLeftIndex > _numNodes)
            {
                return;
            }

            // Check if the left-child is higher-priority than the current node
            int childRightIndex = childLeftIndex + 1;
            T childLeft = _nodes[childLeftIndex];
            if(HasHigherPriority(childLeft, node))
            {
                // Check if there is a right child. If not, swap and finish.
                if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = childLeftIndex;
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    _nodes[childLeftIndex] = node;
                    return;
                }
                // Check if the left-child is higher-priority than the right-child
                T childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childLeft, childRight))
                {
                    // left is highest, move it up and continue
                    childLeft.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childLeft;
                    finalQueueIndex = childLeftIndex;
                }
                else
                {
                    // right is even higher, move it up and continue
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
            }
            // Not swapping with left-child, does right-child exist?
            else if(childRightIndex > _numNodes)
            {
                return;
            }
            else
            {
                // Check if the right-child is higher-priority than the current node
                T childRight = _nodes[childRightIndex];
                if(HasHigherPriority(childRight, node))
                {
                    childRight.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = childRight;
                    finalQueueIndex = childRightIndex;
                }
                // Neither child is higher-priority than current, so finish and stop.
                else
                {
                    return;
                }
            }

            while(true)
            {
                childLeftIndex = 2 * finalQueueIndex;

                // If leaf node, we're done
                if(childLeftIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }

                // Check if the left-child is higher-priority than the current node
                childRightIndex = childLeftIndex + 1;
                childLeft = _nodes[childLeftIndex];
                if(HasHigherPriority(childLeft, node))
                {
                    // Check if there is a right child. If not, swap and finish.
                    if(childRightIndex > _numNodes)
                    {
                        node.QueueIndex = childLeftIndex;
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        _nodes[childLeftIndex] = node;
                        break;
                    }
                    // Check if the left-child is higher-priority than the right-child
                    T childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childLeft, childRight))
                    {
                        // left is highest, move it up and continue
                        childLeft.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childLeft;
                        finalQueueIndex = childLeftIndex;
                    }
                    else
                    {
                        // right is even higher, move it up and continue
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                }
                // Not swapping with left-child, does right-child exist?
                else if(childRightIndex > _numNodes)
                {
                    node.QueueIndex = finalQueueIndex;
                    _nodes[finalQueueIndex] = node;
                    break;
                }
                else
                {
                    // Check if the right-child is higher-priority than the current node
                    T childRight = _nodes[childRightIndex];
                    if(HasHigherPriority(childRight, node))
                    {
                        childRight.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = childRight;
                        finalQueueIndex = childRightIndex;
                    }
                    // Neither child is higher-priority than current, so finish and stop.
                    else
                    {
                        node.QueueIndex = finalQueueIndex;
                        _nodes[finalQueueIndex] = node;
                        break;
                    }
                }
            }
        }

        /// <summary>
        /// Returns true if 'higher' has higher priority than 'lower', false otherwise.
        /// Note that calling HasHigherPriority(node, node) (ie. both arguments the same node) will return false
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        private bool HasHigherPriority(T higher, T lower)
        {
            return (higher.Priority < lower.Priority ||
                (higher.Priority == lower.Priority && higher.InsertionIndex < lower.InsertionIndex));
        }

        /// <summary>
        /// Removes the head of the queue (node with minimum priority; ties are broken by order of insertion), and returns it.
        /// If queue is empty, result is undefined
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public T Dequeue()
        {
            #if DEBUG
            if(_numNodes <= 0)
            {
                throw new InvalidOperationException("Cannot call Dequeue() on an empty queue");
            }

            if(!IsValidQueue())
            {
                throw new InvalidOperationException("Queue has been corrupted (Did you update a node priority manually instead of calling UpdatePriority()?" +
                                                    "Or add the same node to two different queues?)");
            }
            #endif

            T returnMe = _nodes[1];
            //If the node is already the last node, we can remove it immediately
            if(_numNodes == 1)
            {
                _nodes[1] = null;
                _numNodes = 0;
                return returnMe;
            }

            //Swap the node with the last node
            T formerLastNode = _nodes[_numNodes];
            _nodes[1] = formerLastNode;
            formerLastNode.QueueIndex = 1;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) down
            CascadeDown(formerLastNode);
            return returnMe;
        }

        /// <summary>
        /// Resize the queue so it can accept more nodes.  All currently enqueued nodes are remain.
        /// Attempting to decrease the queue size to a size too small to hold the existing nodes results in undefined behavior
        /// O(n)
        /// </summary>
        public void Resize(int maxNodes)
        {
            #if DEBUG
            if (maxNodes <= 0)
            {
                throw new InvalidOperationException("Queue size cannot be smaller than 1");
            }

            if (maxNodes < _numNodes)
            {
                throw new InvalidOperationException("Called Resize(" + maxNodes + "), but current queue contains " + _numNodes + " nodes");
            }
            #endif

            T[] newArray = new T[maxNodes + 1];
            int highestIndexToCopy = Math.Min(maxNodes, _numNodes);
            Array.Copy(_nodes, newArray, highestIndexToCopy + 1);
            _nodes = newArray;
        }

        /// <summary>
        /// Returns the head of the queue, without removing it (use Dequeue() for that).
        /// If the queue is empty, behavior is undefined.
        /// O(1)
        /// </summary>
        public T First
        {
            get
            {
                #if DEBUG
                if(_numNodes <= 0)
                {
                    throw new InvalidOperationException("Cannot call .First on an empty queue");
                }
                #endif

                return _nodes[1];
            }
        }

        /// <summary>
        /// This method must be called on a node every time its priority changes while it is in the queue.  
        /// <b>Forgetting to call this method will result in a corrupted queue!</b>
        /// Calling this method on a node not in the queue results in undefined behavior
        /// O(log n)
        /// </summary>
        #if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        #endif
        public void UpdatePriority(T node, float priority)
        {
            #if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.UpdatePriority was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call UpdatePriority() on a node which is not enqueued: " + node);
            }
            #endif

            node.Priority = priority;
            OnNodeUpdated(node);
        }

#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        private void OnNodeUpdated(T node)
        {
            //Bubble the updated node up or down as appropriate
            int parentIndex = node.QueueIndex >> 1;

            if(parentIndex > 0 && HasHigherPriority(node, _nodes[parentIndex]))
            {
                CascadeUp(node);
            }
            else
            {
                //Note that CascadeDown will be called if parentNode == node (that is, node is the root)
                CascadeDown(node);
            }
        }

        /// <summary>
        /// Removes a node from the queue.  The node does not need to be the head of the queue.  
        /// If the node is not in the queue, the result is undefined.  If unsure, check Contains() first
        /// O(log n)
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void Remove(T node)
        {
#if DEBUG
            if(node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.Remove was called on a node from another queue");
            }
            if (!Contains(node))
            {
                throw new InvalidOperationException("Cannot call Remove() on a node which is not enqueued: " + node);
            }
#endif

            //If the node is already the last node, we can remove it immediately
            if(node.QueueIndex == _numNodes)
            {
                _nodes[_numNodes] = null;
                _numNodes--;
                return;
            }

            //Swap the node with the last node
            T formerLastNode = _nodes[_numNodes];
            _nodes[node.QueueIndex] = formerLastNode;
            formerLastNode.QueueIndex = node.QueueIndex;
            _nodes[_numNodes] = null;
            _numNodes--;

            //Now bubble formerLastNode (which is no longer the last node) up or down as appropriate
            OnNodeUpdated(formerLastNode);
        }

        /// <summary>
        /// By default, nodes that have been previously added to one queue cannot be added to another queue.
        /// If you need to do this, please call originalQueue.ResetNode(node) before attempting to add it in the new queue
        /// </summary>
#if NET_VERSION_4_5
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
#endif
        public void ResetNode(T node)
        {
#if DEBUG
            if (node == null)
            {
                throw new ArgumentNullException("node");
            }
            if (node.Queue != null && !Equals(node.Queue))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node from another queue");
            }
            if (Contains(node))
            {
                throw new InvalidOperationException("node.ResetNode was called on a node that is still in the queue");
            }

            node.Queue = null;
#endif

            node.QueueIndex = 0;
        }


        public IEnumerator<T> GetEnumerator()
        {
#if NET_VERSION_4_5 // ArraySegment does not implement IEnumerable before 4.5
            IEnumerable<T> e = new ArraySegment<T>(_nodes, 1, _numNodes);
            return e.GetEnumerator();
#else
            for(int i = 1; i <= _numNodes; i++)
                yield return _nodes[i];
#endif
        }

        IEnumerator IEnumerable.GetEnumerator()
        {
            return GetEnumerator();
        }

        /// <summary>
        /// <b>Should not be called in production code.</b>
        /// Checks to make sure the queue is still in a valid state.  Used for testing/debugging the queue.
        /// </summary>
        public bool IsValidQueue()
        {
            for(int i = 1; i < _nodes.Length; i++)
            {
                if(_nodes[i] != null)
                {
                    int childLeftIndex = 2 * i;
                    if(childLeftIndex < _nodes.Length && _nodes[childLeftIndex] != null && HasHigherPriority(_nodes[childLeftIndex], _nodes[i]))
                        return false;

                    int childRightIndex = childLeftIndex + 1;
                    if(childRightIndex < _nodes.Length && _nodes[childRightIndex] != null && HasHigherPriority(_nodes[childRightIndex], _nodes[i]))
                        return false;
                }
            }
            return true;
        }
    }
}
---
Script: StablePriorityQueueNode.cs (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\StablePriorityQueueNode.cs)

﻿namespace Priority_Queue
{
    public class StablePriorityQueueNode : FastPriorityQueueNode
    {
        /// <summary>
        /// Represents the order the node was inserted in
        /// </summary>
        public long InsertionIndex { get; internal set; }
    }
}

---
Script: Chunk.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\Chunk.cs)

﻿using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Mathematics;
using UnityEngine;
using UnityEngine.Rendering;

[RequireComponent(typeof(MeshRenderer))]
[RequireComponent(typeof(MeshFilter))]
[RequireComponent(typeof(MeshCollider))]
public partial class Chunk : MonoBehaviour
{
    TerrainManager generator;
    public Vector3Int chunkPosition;
    Vector3Int chunkSize;
    bool argent; // ?
    Voxel[] voxels;
    Coroutine meshUpdater;

    Mesh mesh;
    MeshFilter meshFilter;
    MeshRenderer meshRenderer;
    MeshCollider meshCollider;

    public event Func<bool> CanUpdate;

    NoiseGenerator.NativeVoxelData voxelData;
    ChunkMeshBuilder.NativeMeshData meshData;

    public bool Dirty { get; private set; }
    public bool Updating => meshUpdater != null;
    public bool Initialized { get; private set; }
    public bool Itemized { get; set; }
    public Voxel[] Voxels => voxels;

    public int3[] groundVoxels;

    // Awake is called immediately after instantiation.
    void Awake()
    {
        meshFilter = GetComponent<MeshFilter>();
        meshRenderer = GetComponent<MeshRenderer>();
        meshCollider = GetComponent<MeshCollider>();
        mesh = new Mesh { indexFormat = IndexFormat.UInt32 }; // Allows bigger meshes to be rendered.
        CanUpdate = () => true; // This is replaced by a delegate before Update happens. No idea why this exists.
    }

    void OnDestroy()
    {
        voxelData?.jobHandle.Complete();
        voxelData?.Dispose();
        meshData?.jobHandle.Complete();
        meshData?.Dispose();
        DestroyAllItems();
    }

    void Start()
    {
        meshFilter.mesh = mesh;
    }

    public void Init(Vector3Int position, TerrainManager parent)
    {
        chunkPosition = position;
        generator = parent;

        meshRenderer.material = generator.ChunkMaterial;
        chunkSize = generator.ChunkSize;

        if (TryInitByLoad())
        {
            return; // Do something else?
        }

        StartCoroutine(nameof(InitByNoise));
    }

    IEnumerator InitByNoise()
    {
        int numVoxels = chunkSize.x * chunkSize.y * chunkSize.z;
        voxels = new Voxel[numVoxels];
        voxelData = new NoiseGenerator.NativeVoxelData(VoxelUtil.ToInt3(chunkSize));
        yield return voxelData.Generate(voxels, VoxelUtil.ToInt3(chunkPosition), VoxelUtil.ToInt3(chunkSize));
        Dirty = true;
        Initialized = true;
    }

    void Update()
    {
        if (!Initialized)
            return;

        if (Updating)
            return;

        if (!Dirty)
            return;

        if (CanUpdate == null || !CanUpdate())
            return;

        meshUpdater = StartCoroutine(nameof(UpdateMesh));
    }

    IEnumerator UpdateMesh()
    {
        if (Updating)
            yield break;

        if (!generator.CanUpdate)
            yield break;

        generator.UpdatingChunks++;

        int3 chunkSizeInt3 = VoxelUtil.ToInt3(chunkSize);

        // Was used for lighting job, no longer necessary 
        //List<Voxel[]> neighborVoxels = generator.GetNeighborVoxels(chunkPosition, 1);

        meshData?.Dispose();
        meshData = new ChunkMeshBuilder.NativeMeshData(VoxelUtil.ToInt3(chunkSize));

        // Light data is no longer passed to meshing job.
        yield return meshData.ScheduleMeshingJob(voxels, VoxelUtil.ToInt3(chunkSize), argent);

        meshData.GetMeshInformation(out int verticeSize, out int indicesSize);

        if (verticeSize > 0 && indicesSize > 0)
        {
            mesh.Clear();
            mesh.SetVertices(meshData.nativeVertices, 0, verticeSize);
            mesh.SetNormals(meshData.nativeNormals, 0, verticeSize);
            mesh.SetUVs(0, meshData.nativeUVs, 0, verticeSize);
            mesh.SetIndices(meshData.nativeIndices, 0, indicesSize, MeshTopology.Triangles, 0); // Triangles

            mesh.RecalculateNormals();
            mesh.RecalculateBounds();
            mesh.RecalculateTangents();

            if (argent)
                SetSharedMesh(mesh); // When setting a single voxel, the collider doesn't need rebuilding?
            else
                ChunkColliderBuilder.Main.Enqueue(this, mesh);

            groundVoxels = new int3[meshData.groundCounter.Count];
            Array.Copy(meshData.nativeGroundVoxels.ToArray(), groundVoxels, meshData.groundCounter.Count);

            if (!Itemized)
            {
                ChunkObjectSpawner.Main.Enqueue(this);
                // ground positions are kept, but we don't know which are occupied (that's okay)
            }
        }

        meshData.Dispose();
        Dirty = false;
        argent = false;
        gameObject.layer = LayerMask.NameToLayer("Voxel");
        meshUpdater = null;
        generator.UpdatingChunks--;
    }

    public void SetSharedMesh(Mesh bakedMesh)
    {
        meshCollider.sharedMesh = bakedMesh;
    }

    public bool GetVoxel(Vector3Int gridPosition, out Voxel voxel)
    {
        if (!Initialized)
        {
            voxel = VoxelUtil.Empty;
            return false;
        }

        if (!VoxelUtil.BoundaryCheck(gridPosition, chunkSize))
        {
            voxel = VoxelUtil.Empty;
            return false;
        }

        voxel = voxels[VoxelUtil.To1DIndex(gridPosition, chunkSize)];
        return true;
    }

    public bool SetVoxel(Vector3Int gridPosition, Voxel type)
    {
        if (!Initialized)
        {
            return false;
        }

        if (!VoxelUtil.BoundaryCheck(gridPosition, chunkSize))
        {
            return false;
        }

        voxels[VoxelUtil.To1DIndex(gridPosition, chunkSize)] = type;
        Dirty = true;
        argent = true;
        modified = true;
        return true;
    }

    public void NeighborChunkIsChanged()
    {
        Dirty = true;
        argent = true;
    }

    void OnDrawGizmos()
    {
        if (!Initialized)
        {
            Gizmos.color = Color.yellow;
            Gizmos.DrawWireCube(transform.position + new Vector3(chunkSize.x / 2f, chunkSize.y / 2f, chunkSize.z / 2f), chunkSize);
        }
        else if (Initialized && Dirty)
        {
            Gizmos.color = Color.white;
            Gizmos.DrawWireCube(transform.position + new Vector3(chunkSize.x / 2f, chunkSize.y / 2f, chunkSize.z / 2f), chunkSize);
        }
    }
}

---
Script: ChunkColliderBuilder.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkColliderBuilder.cs)

using System;
using System.Collections;
using System.Collections.Generic;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using UnityEngine;

public class ChunkColliderBuilder : Singleton<ChunkColliderBuilder>
{

    struct MeshNode
    {
        public Chunk chunk;
        public Mesh mesh;
    }

    List<MeshNode> meshes = new List<MeshNode>();
    NativeArray<int> meshIds;
    JobHandle jobHandle;

    public void Enqueue(Chunk chunk, Mesh mesh)
    {
        meshes.Add(new MeshNode { chunk = chunk, mesh = mesh });
    }

    void Start()
    {
        StartCoroutine(nameof(BakeUpdator));
    }

    void OnDestroy()
    {
        jobHandle.Complete();

        if (meshIds.IsCreated)
            meshIds.Dispose();
    }

    IEnumerator BakeUpdator()
    {
        int counter = 0;
        while (true)
        {
            if (meshes.Count == 0)
            {
                counter = 0;
                yield return null;
                continue;
            }

            if (counter < 4 && meshes.Count < 5)
            {
                counter++;
                yield return null;
                continue;
            }

            meshIds = new NativeArray<int>(meshes.Count, Allocator.TempJob);

            for (int i = 0; i < meshes.Count; ++i)
            {
                meshIds[i] = meshes[i].mesh.GetInstanceID();
            }

            BakeJob bakeJob = new BakeJob { meshIds = meshIds };
            jobHandle = bakeJob.Schedule(meshIds.Length, 32);
            JobHandle.ScheduleBatchedJobs();
            int frameCount = 1;
            yield return new WaitUntil(() =>
            {
                frameCount++;
                return jobHandle.IsCompleted || frameCount >= 4;
            });
            jobHandle.Complete();
            meshIds.Dispose();

            for (int i = 0; i < meshes.Count; i++)
            {
                meshes[i].chunk.SetSharedMesh(meshes[i].mesh);
            }

            meshes.Clear();
            counter = 0;
            ChunkObjectSpawner.Main.Itemize();
            yield return null;
        }
    }

    [BurstCompile]
    public struct BakeJob : IJobParallelFor
    {
        public NativeArray<int> meshIds;

        public void Execute(int index)
        {
            Physics.BakeMesh(meshIds[index], false);
        }
    }
}
---
Script: ChunkMeshBuilder.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkMeshBuilder.cs)

using System.Collections;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class ChunkMeshBuilder
{
    public static readonly int2 AtlasSize = VoxelUtil.AtlasSize;
    //private static readonly int nonBlocks = VoxelUtil.nonBlocks;

    public static void InitializeShaderParameter()
    {
        Shader.SetGlobalInt("_AtlasX", AtlasSize.x);
        Shader.SetGlobalInt("_AtlasY", AtlasSize.y);
        Shader.SetGlobalVector("_AtlasRec", new Vector4(1.0f / AtlasSize.x, 1.0f / AtlasSize.y));
    }

    public enum SimplifyingMethod
    {
        Culling,
        GreedyOnlyHeight,
        Greedy
    };

    public class NativeMeshData
    {

        NativeArray<Voxel> nativeVoxels;
        public NativeArray<float3> nativeVertices;
        public NativeArray<float3> nativeNormals;
        public NativeArray<int> nativeIndices;
        public NativeArray<float4> nativeUVs;
        public JobHandle jobHandle;
        NativeCounter faceCounter;

        public NativeArray<int3> nativeGroundVoxels;
        public NativeCounter groundCounter;

        public NativeMeshData(int3 chunkSize)
        {
            int numVoxels = chunkSize.x * chunkSize.y * chunkSize.z;
            int maxVertices = 12 * numVoxels;
            int maxIndices = 18 * numVoxels;

            nativeVoxels = new NativeArray<Voxel>(numVoxels, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            nativeVertices = new NativeArray<float3>(maxVertices, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            nativeNormals = new NativeArray<float3>(maxVertices, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            nativeUVs = new NativeArray<float4>(maxVertices, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            nativeIndices = new NativeArray<int>(maxIndices, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            faceCounter = new NativeCounter(Allocator.TempJob);

            nativeGroundVoxels = new NativeArray<int3>(numVoxels / 2, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);
            groundCounter = new NativeCounter(Allocator.TempJob);
        }

        ~NativeMeshData()
        {
            jobHandle.Complete();
            Dispose();
        }

        public void Dispose()
        {
            if (nativeVoxels.IsCreated)
                nativeVoxels.Dispose();

            if (nativeVertices.IsCreated)
                nativeVertices.Dispose();

            if (nativeNormals.IsCreated)
                nativeNormals.Dispose();

            if (nativeIndices.IsCreated)
                nativeIndices.Dispose();

            if (faceCounter.IsCreated)
                faceCounter.Dispose();

            if (nativeUVs.IsCreated)
                nativeUVs.Dispose();

            if (nativeGroundVoxels.IsCreated)
                nativeGroundVoxels.Dispose();

            if (groundCounter.IsCreated)
                groundCounter.Dispose();
        }

        public IEnumerator ScheduleMeshingJob(Voxel[] voxels, int3 chunkSize, bool argent = false)
        {
            nativeVoxels.CopyFrom(voxels);
            ScheduleGreedyJob(nativeVoxels, chunkSize);

            int frameCount = 0;
            yield return new WaitUntil(() =>
            {
                frameCount++;
                return jobHandle.IsCompleted || frameCount >= 4 || argent; // Seems very important.
            });

            jobHandle.Complete();
        }

        public void GetMeshInformation(out int verticeSize, out int indicesSize)
        {
            verticeSize = faceCounter.Count * 4;
            indicesSize = faceCounter.Count * 6;
        }

        void ScheduleGreedyJob(NativeArray<Voxel> voxels, int3 chunkSize)
        {
            VoxelGreedyMeshingJob voxelMeshingJob = new VoxelGreedyMeshingJob
            {
                voxels = voxels,
                chunkSize = chunkSize,
                vertices = nativeVertices,
                normals = nativeNormals,
                uvs = nativeUVs,
                indices = nativeIndices,
                faceCounter = faceCounter,
                groundVoxels = nativeGroundVoxels,
                groundCounter = groundCounter
            };

            jobHandle = voxelMeshingJob.Schedule();
            JobHandle.ScheduleBatchedJobs();
        }
    }

    [BurstCompile]
    struct VoxelGreedyMeshingJob : IJob
    {
        [ReadOnly] public NativeArray<Voxel> voxels;
        [ReadOnly] public int3 chunkSize;

        [NativeDisableParallelForRestriction]
        [WriteOnly]
        public NativeArray<float3> vertices;

        [NativeDisableParallelForRestriction]
        [WriteOnly]
        public NativeArray<float3> normals;

        [NativeDisableParallelForRestriction]
        [WriteOnly]
        public NativeArray<float4> uvs;

        [NativeDisableParallelForRestriction]
        [WriteOnly]
        public NativeArray<int> indices;

        [WriteOnly] public NativeCounter faceCounter;


        [NativeDisableParallelForRestriction]
        [WriteOnly]
        public NativeArray<int3> groundVoxels;

        [WriteOnly] public NativeCounter groundCounter;

        struct Empty { }

        // Left here
        public void Execute()
        {
            // For each dir
            for (int direction = 0; direction < 6; direction++)
            {
                // Contains inspected blocks.
                NativeParallelHashMap<int3, Empty> inspected = new NativeParallelHashMap<int3, Empty>(chunkSize[VoxelUtil.DirectionAlignedX[direction]] * chunkSize[VoxelUtil.DirectionAlignedY[direction]], Allocator.Temp);

                // Goes through depth of the chunk (z) swiping on x and y axis.
                for (int depth = 0; depth < chunkSize[VoxelUtil.DirectionAlignedZ[direction]]; depth++)
                {
                    for (int x = 0; x < chunkSize[VoxelUtil.DirectionAlignedX[direction]]; x++)
                    {
                        for (int y = 0; y < chunkSize[VoxelUtil.DirectionAlignedY[direction]];)
                        {
                            // Get block grid position and block itself
                            int3 gridPosition = new int3 { [VoxelUtil.DirectionAlignedX[direction]] = x, [VoxelUtil.DirectionAlignedY[direction]] = y, [VoxelUtil.DirectionAlignedZ[direction]] = depth };

                            Voxel voxel = voxels[VoxelUtil.To1DIndex(gridPosition, chunkSize)];

                            if (voxel == Voxel.Air)
                            {
                                y++;
                                continue;
                            }

                            if (inspected.ContainsKey(gridPosition))
                            {
                                y++;
                                continue;
                            }

                            // Block is not air and wasn't inspected before!

                            // Get neighbour in current direction.
                            int3 neighborPosition = gridPosition + VoxelUtil.VoxelDirectionOffsets[direction];

                            if (!IsTransparent(voxels, neighborPosition, chunkSize))
                            {
                                // If neighbour is not transparent, no face needed
                                y++;
                                continue;
                            }

                            // Neighbour is transparent so face must be created!

                            // Adds block to inspected set
                            inspected.TryAdd(gridPosition, new Empty());

                            // Expands quad as much as possible
                            int height;
                            for (height = 1; height + y < chunkSize[VoxelUtil.DirectionAlignedY[direction]]; height++)
                            {
                                int3 nextPosition = gridPosition;
                                nextPosition[VoxelUtil.DirectionAlignedY[direction]] += height;

                                Voxel nextVoxel = voxels[VoxelUtil.To1DIndex(nextPosition, chunkSize)];

                                if (nextVoxel != voxel)
                                    break;

                                if (inspected.ContainsKey(nextPosition))
                                    break;

                                inspected.TryAdd(nextPosition, new Empty());
                            }

                            bool isDone = false;
                            int width;
                            for (width = 1; width + x < chunkSize[VoxelUtil.DirectionAlignedX[direction]]; width++)
                            {
                                for (int dy = 0; dy < height; dy++)
                                {
                                    int3 nextPosition = gridPosition;
                                    nextPosition[VoxelUtil.DirectionAlignedX[direction]] += width;
                                    nextPosition[VoxelUtil.DirectionAlignedY[direction]] += dy;

                                    Voxel nextVoxel = voxels[VoxelUtil.To1DIndex(nextPosition, chunkSize)];

                                    if (nextVoxel != voxel || inspected.ContainsKey(nextPosition))
                                    {
                                        isDone = true;
                                        break;
                                    }
                                }

                                if (isDone)
                                {
                                    break;
                                }

                                for (int dy = 0; dy < height; dy++)
                                {
                                    int3 nextPosition = gridPosition;
                                    nextPosition[VoxelUtil.DirectionAlignedX[direction]] += width;
                                    nextPosition[VoxelUtil.DirectionAlignedY[direction]] += dy;
                                    inspected.TryAdd(nextPosition, new Empty());
                                }
                            }

                            AddQuadByDirection(direction, voxel, width, height, gridPosition, faceCounter.Increment(), vertices, normals, uvs, indices, groundVoxels, groundCounter);
                            y += height;
                        }
                    }

                    inspected.Clear();
                }
                inspected.Dispose();
            }
        }
    }

    public static bool IsTransparent(NativeArray<Voxel> voxels, int3 position, int3 chunkSize)
    {
        if (!VoxelUtil.BoundaryCheck(position, chunkSize))
            return true;

        return voxels[VoxelUtil.To1DIndex(position, chunkSize)] == Voxel.Air;
    }

    static unsafe void AddQuadByDirection(int direction, Voxel data, float width, float height, int3 gridPosition, int faceIndex, NativeArray<float3> vertices, NativeArray<float3> normals, NativeArray<float4> uvs, NativeArray<int> indices, NativeArray<int3> groundVoxels, NativeCounter groundCounter)
    {
        int firstVertexIndex = faceIndex * 4;
        for (int i = 0; i < 4; i++)
        {
            float3 vertex = VoxelUtil.CubeVertices[VoxelUtil.CubeFaces[i + direction * 4]];
            vertex[VoxelUtil.DirectionAlignedX[direction]] *= width;
            vertex[VoxelUtil.DirectionAlignedY[direction]] *= height;

            // Determines which texture get picked from atlas
            int atlasIndex = (int)data * 6 + direction; // Direction = 0,1,4,5:sides 2:up 3:down
            int2 atlasPosition = new int2 { x = atlasIndex % AtlasSize.x, y = atlasIndex / AtlasSize.x };

            float4 uv = new float4 { x = VoxelUtil.CubeUVs[i].x * width, y = VoxelUtil.CubeUVs[i].y * height, z = atlasPosition.x, w = atlasPosition.y };

            vertices[firstVertexIndex + i] = vertex + gridPosition;
            normals[firstVertexIndex + i] = VoxelUtil.VoxelDirectionOffsets[direction];
            uvs[firstVertexIndex + i] = uv;
        }
        // For each face -> 2 tris -> 6 indices
        int firstIndiceIndex = faceIndex * 6;
        // Figure out wtf was happening here before
        for (int i = 0; i < 6; i++)
        {
            // Compare the light sum of each pair of vertices.
            indices[firstIndiceIndex + i] = VoxelUtil.CubeIndices[direction * 6 + i] + firstVertexIndex;
        }

        if (direction == 2 && gridPosition.y < Consts.ChunkSizeVertical - 1)
        {
            for (int i = 0; i < width; i++)
            {
                for (int j = 0; j < height; j++)
                {
                    groundVoxels[groundCounter.Increment()] = new int3(gridPosition.x + i, gridPosition.y, gridPosition.z + j);
                }
            }
        }
    }
}
---
Script: ChunkObjectSpawner.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkObjectSpawner.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Unity.Mathematics;

public class ChunkObjectSpawner : Singleton<ChunkObjectSpawner>
{

    Queue<Chunk> chunksToItemize = new Queue<Chunk>();

    int maxItemizeChunksInFrame = 10;

    public void Enqueue(Chunk chunk)
    {
        chunksToItemize.Enqueue(chunk);
    }

    public void Itemize()
    {
        StartCoroutine(ProcessItemization());
    }

    IEnumerator ProcessItemization()
    {
        int itemizedChunks = 0;
        while (chunksToItemize.Count > 0)
        {
            if (itemizedChunks >= maxItemizeChunksInFrame)
                yield return null;
            Chunk chunk = chunksToItemize.Dequeue();
            ChunkRandomSpawn(chunk);
            chunk.Itemized = true;
            itemizedChunks++;
        }
    }

    // Assumes all items are snapped on center
    public void ChunkRandomSpawn(Chunk chunk)
    {
        HashSet<int3> occupiedGround = new HashSet<int3>();

        // Spawn each item
        RandomSpawnItem(ItemDatabase.Main.GetCopy("Hobbit"), 3, 7, chunk.chunkPosition, chunk.groundVoxels, occupiedGround);
    }

    public void RandomSpawnItem(Item item, int minAmount, int maxAmount, Vector3Int chunkPos, int3[] groundVoxels, HashSet<int3> occupiedGround, int minStack = 1, int maxStack = 1)
    {
        int amountToSpawn = UnityEngine.Random.Range(minAmount, maxAmount + 1);

        int spawnedAmount = 0;
        while (spawnedAmount < amountToSpawn)
        {
            int r = UnityEngine.Random.Range(0, groundVoxels.Length);
            if (occupiedGround.Contains(groundVoxels[r]))
                continue;

            Vector3Int gridPos = new Vector3Int(groundVoxels[r].x, groundVoxels[r].y, groundVoxels[r].z);
            Vector3 worldPos = VoxelUtil.GridToWorld(gridPos, chunkPos, Consts.ChunkSize);
            worldPos += ItemUtil.Corner2TopMid;

            // Voxel isn't occupied, will try to spawn!
            int stack = UnityEngine.Random.Range(minStack, maxStack + 1);
            ItemStack itemStack = new ItemStack(item, stack);

            if (SpawnManager.Main.TryPopulate(Vector3.zero, worldPos, itemStack))
            {
                spawnedAmount++;
                occupiedGround.Add(groundVoxels[r]);
            }
        }
    }
}

---
Script: ChunkPersistance.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkPersistance.cs)

﻿using UnityEngine;
using System.Collections;
using System;
using System.IO;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections.Generic;

public partial class Chunk : MonoBehaviour
{

    public bool modified = false;

    public void Save()
    {
        string path = SaveUtil.GetChunkPath(chunkPosition);

        ChunkData data = new ChunkData(this);

        BinaryFormatter formatter = new BinaryFormatter();
        FileStream stream = new FileStream(path, FileMode.Create);
        formatter.Serialize(stream, data);
        stream.Close();
    }

    public bool TryInitByLoad()
    {
        // Tries to get save file
        string path = SaveUtil.GetChunkPath(chunkPosition);

        if (!File.Exists(path))
        {
            return false;
        }

        // If it succeeds, loads the file

        BinaryFormatter formatter = new BinaryFormatter();
        FileStream stream = new FileStream(path, FileMode.Open);
        ChunkData data = formatter.Deserialize(stream) as ChunkData;
        this.voxels = (Voxel[])(object)data.voxelData;
        foreach (WorldObjectData wid in data.worldItemData)
        {
            SpawnManager.Main.SpawnByLoad(wid, out WorldObject worldItem);
            AddItem(worldItem);
        }
        stream.Close();

        Dirty = true;
        Initialized = true;
        Itemized = true;
        return true;
    }

    HashSet<WorldObject> worldItems = new HashSet<WorldObject>();

    public void AddItem(WorldObject worldItem)
    {
        worldItems.Add(worldItem);
        modified = true;
    }

    public void RemoveItem(WorldObject worldItem)
    {
        worldItems.Remove(worldItem);
        modified = true;
    }

    public void DestroyAllItems()
    {
        foreach (WorldObject wi in worldItems)
        {
            Destroy(wi.gameObject);
        }
        worldItems.Clear();
    }

    [Serializable]
    public class ChunkData // Maybe do nested data classes for all serializables?
    {
        public byte[] voxelData;

        public WorldObjectData[] worldItemData;

        public ChunkData(Chunk chunk)
        {
            voxelData = Array.ConvertAll(chunk.voxels, new Converter<Voxel, byte>(SaveUtil.VoxelToByte));
            worldItemData = new WorldObjectData[chunk.worldItems.Count];
            int i = 0;
            foreach (WorldObject wi in chunk.worldItems)
            {
                worldItemData[i++] = wi.GetData();
            }
        }
    }
}
---
Script: NoiseGenerator.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\NoiseGenerator.cs)

using System.Collections;
using Unity.Burst;
using Unity.Collections;
using Unity.Jobs;
using Unity.Mathematics;
using UnityEngine;

public static class NoiseGenerator
{
    //static void RandomVoxel(out Voxel voxel, int3 worldPosition)
    //{
    //    voxel = new Voxel();
    //    int density = -worldPosition.y + 64;

    //    density += (int)(SimplexNoise.Noise.CalcPixel2DFractal(worldPosition.x, worldPosition.z, 0.003f, 1) * 25f);
    //    density += (int)(SimplexNoise.Noise.CalcPixel2DFractal(worldPosition.x, worldPosition.z, 0.03f, 3) * 5f);
    //    density += (int)(SimplexNoise.Noise.CalcPixel2DFractal(worldPosition.x, worldPosition.z, 0.09f, 5) * 1f);

    //    int level = 0;
    //    if (density >= level)
    //    {
    //        voxel = Voxel.Grass;
    //        level += 1;
    //    }

    //    if (density >= level)
    //    {
    //        voxel = Voxel.Dirt;
    //        level += (int) (SimplexNoise.Noise.CalcPixel2DFractal(worldPosition.x, worldPosition.z, 0.01f, 1) * 10f) + 3;
    //    }

    //    if (density >= level)
    //        voxel = Voxel.Stone;
    //}

    static void RandomVoxel(out Voxel voxel, int3 worldPosition)
    {
        voxel = new Voxel();

        float noise = SimplexNoise.Noise.CalcPixel3DFractal(worldPosition.x, worldPosition.y, worldPosition.z, 0.03f, 3);

        if (noise < .65f)
        {
            float n1 = SimplexNoise.Noise.CalcPixel3DFractal(worldPosition.x, worldPosition.y, worldPosition.z, 0.09f, 3);

            if (n1 < .25f)
            {
                // Common resource
                voxel = Voxel.Brick;
                return;
            }
            voxel = Voxel.Stone;
            return;
        }
        if (noise > .9)
        {
            voxel = Voxel.Magic;
        }
    }

    [BurstCompile]
    struct GenerateNoiseJob : IJobParallelFor
    {
        [ReadOnly] public int3 chunkPosition;
        [ReadOnly] public int3 chunkSize;

        [WriteOnly] public NativeArray<Voxel> voxels;

        public void Execute(int index)
        {
            int3 gridPosition = VoxelUtil.To3DIndex(index, chunkSize);
            int3 worldPosition = gridPosition + chunkPosition * chunkSize;

            RandomVoxel(out Voxel voxel, worldPosition);

            voxels[index] = voxel;
        }
    }

    public class NativeVoxelData
    {
        NativeArray<Voxel> nativeVoxels;
        public JobHandle jobHandle;

        public NativeVoxelData(int3 chunkSize)
        {
            int numVoxels = chunkSize.x * chunkSize.y * chunkSize.z;
            nativeVoxels = new NativeArray<Voxel>(numVoxels, Allocator.TempJob, NativeArrayOptions.UninitializedMemory);

        }

        ~NativeVoxelData()
        {
            jobHandle.Complete();
            Dispose();
        }

        public void Dispose()
        {
            if (nativeVoxels.IsCreated)
                nativeVoxels.Dispose();
        }

        public IEnumerator Generate(Voxel[] voxels, int3 chunkPosition, int3 chunkSize)
        {
            nativeVoxels.CopyFrom(voxels);

            GenerateNoiseJob noiseJob = new GenerateNoiseJob { chunkPosition = chunkPosition, chunkSize = chunkSize, voxels = nativeVoxels };
            jobHandle = noiseJob.Schedule(nativeVoxels.Length, 32);
            JobHandle.ScheduleBatchedJobs();
            int frameCount = 1;
            yield return new WaitUntil(() =>
            {
                frameCount++;
                return jobHandle.IsCompleted || frameCount >= 4;
            });
            jobHandle.Complete();

            nativeVoxels.CopyTo(voxels);
            nativeVoxels.Dispose();
        }
    }


}
---
Script: TerrainPersistance.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\TerrainPersistance.cs)

﻿using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System;
using Priority_Queue;

public partial class TerrainManager : Singleton<TerrainManager>
{
    [SerializeField]
    [Tooltip("Chunks outside keep size are saved and destroyed.")]
    Vector2Int chunkKeepSize = Vector2Int.one * 3;
    [SerializeField]
    int maxSaveChunksInFrame = 5;

    FastPriorityQueue<ChunkNode> saveChunkQueue = new FastPriorityQueue<ChunkNode>(100000);

    public void SaveFarawayChunks(Vector3Int targetPosition)
    {
        foreach (KeyValuePair<Vector3Int, Chunk> kv in chunks)
        {
            Vector3Int deltaPosition = targetPosition - kv.Key;
            if (Mathf.Abs(deltaPosition.x) > chunkKeepSize.x || Mathf.Abs(deltaPosition.y) > chunkKeepSize.y || Mathf.Abs(deltaPosition.z) > chunkKeepSize.x)
            {
                // Chunk is outside keepSize! Check if it must be saved
                if (!kv.Value.modified)
                    continue;

                kv.Value.modified = false;
                // Then, if it's on queue, update priority, if it's not, enqueue it.
                ChunkNode chunkNode = new ChunkNode { chunkPosition = kv.Key };
                if (saveChunkQueue.Contains(chunkNode))
                {
                    saveChunkQueue.UpdatePriority(chunkNode, -deltaPosition.sqrMagnitude);
                    continue;
                }
                saveChunkQueue.Enqueue(chunkNode, -deltaPosition.sqrMagnitude);
            }
        }
    }

    private void ProcessSaveChunkQueue()
    {
        int savedChunks = 0;
        while (saveChunkQueue.Count != 0)
        {
            if (savedChunks > maxSaveChunksInFrame)
                return;

            Vector3Int chunkPosition = saveChunkQueue.Dequeue().chunkPosition;
            // Save and get rid of chunk terrain
            Chunk chunk = chunks[chunkPosition];
            chunk.Save(); // Saves item and voxel data

            chunks.Remove(chunkPosition);
            Destroy(chunk.gameObject);
            savedChunks++;
        }
    }

    public void SaveAll()
    {
        Vector3Int targetPosition = VoxelUtil.WorldToChunk(target.position, chunkSize);

        // AutoSave all current chunks
        foreach (KeyValuePair<Vector3Int, Chunk> kv in chunks)
        {
            kv.Value.Save();
        }

        // Destroy all chunks in save queue (clearing it)
        while (saveChunkQueue.Count != 0)
        {
            Vector3Int chunkPosition = saveChunkQueue.Dequeue().chunkPosition;
            Chunk chunk = chunks[chunkPosition];
            chunks.Remove(chunkPosition);
            Destroy(chunk.gameObject);
        }
    }

    #region ITEM PERSISTENCE

    public void AddItem(Vector3 worldPosition, WorldObject worldItem)
    {
        Vector3Int chunkPosition = VoxelUtil.WorldToChunk(worldPosition, Consts.ChunkSize);
        chunks[chunkPosition].AddItem(worldItem);
    }

    public void RemoveItem(WorldObject worldItem)
    {
        Vector3Int chunkPosition = VoxelUtil.WorldToChunk(worldItem.transform.position, Consts.ChunkSize);
        chunks[chunkPosition].RemoveItem(worldItem);
    }

    public void DestroyChunkItems(Vector3Int chunkPosition)
    {
        chunks[chunkPosition].DestroyAllItems();
    }

    #endregion
}

---
Script: Voxel.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\Voxel.cs)

﻿
// RULE: Air comes first, then block types, then non-block types
public enum Voxel : byte { Air, Stone, Brick, Magic, Dirt, Grass, Object }
---
Script: VoxelUtil.cs (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\VoxelUtil.cs)

using Unity.Mathematics;
using UnityEngine;

public static class VoxelUtil
{

    public static readonly int2 AtlasSize = new int2(8, 8);

    public static Voxel Empty => Voxel.Air;

    public static int3 To3DIndex(int index, int3 chunkSize)
    {
        return new int3 { z = index % chunkSize.z, y = (index / chunkSize.z) % chunkSize.y, x = index / (chunkSize.y * chunkSize.z) };
    }

    public static int To1DIndex(int3 index, int3 chunkSize)
    {
        return index.z + index.y * chunkSize.z + index.x * chunkSize.y * chunkSize.z;
    }

    public static int To1DIndex(Vector3Int index, Vector3Int chunkSize)
    {
        return To1DIndex(new int3(index.x, index.y, index.z), new int3(chunkSize.x, chunkSize.y, chunkSize.z));
    }

    public static int3 WorldToChunk(int3 worldGridPosition, int3 chunkSize)
    {
        return new int3
        {
            x = Floor((float)worldGridPosition.x / chunkSize.x),
            y = Floor((float)worldGridPosition.y / chunkSize.y),
            z = Floor((float)worldGridPosition.z / chunkSize.z)
        };
    }

    public static Vector3Int WorldToChunk(Vector3 worldPosition, Vector3Int chunkSize)
    {
        // Chunk position is indexed as a matrix including negative indexes (does not reflect world position)
        return new Vector3Int
        {
            x = Floor(worldPosition.x / chunkSize.x),
            y = Floor(worldPosition.y / chunkSize.y),
            z = Floor(worldPosition.z / chunkSize.z)
        };
    }

    public static Vector3 ChunkToWorld(Vector3Int chunkPosition, Vector3Int chunkSize)
    {
        return chunkPosition * chunkSize;
    }

    public static Vector3 GridToWorld(Vector3Int gridPosition, Vector3Int chunkPosition, Vector3Int chunkSize)
    {
        return ChunkToWorld(chunkPosition, chunkSize) + gridPosition;
    }

    public static Vector3Int WorldToGrid(Vector3 worldPosition, Vector3Int chunkPosition, Vector3Int chunkSize)
    {
        return ToVector3Int(WorldToGrid(Floor(worldPosition), ToInt3(chunkPosition), ToInt3(chunkSize)));
    }

    public static int3 WorldToGrid(int3 worldGridPosition, int3 chunkPosition, int3 chunkSize)
    {
        // Position relative to chunk bottom-left corner
        int3 posRelChunk = worldGridPosition - chunkPosition * chunkSize;

        return Mod(posRelChunk, chunkSize);
    }

    public static bool BoundaryCheck(int3 position, int3 chunkSize)
    {
        return chunkSize.x > position.x && chunkSize.y > position.y && chunkSize.z > position.z && position.x >= 0 && position.y >= 0 && position.z >= 0;
    }

    public static bool BoundaryCheck(Vector3Int position, Vector3Int chunkSize)
    {
        return chunkSize.x > position.x && chunkSize.y > position.y && chunkSize.z > position.z && position.x >= 0 && position.y >= 0 && position.z >= 0;
    }

    public static Vector3Int ToVector3Int(int3 v) => new Vector3Int(v.x, v.y, v.z);

    public static int3 ToInt3(Vector3Int v) => new int3(v.x, v.y, v.z);

    public static int InvertDirection(int direction)
    {
        int axis = direction / 2; // 0(+x,-x), 1(+y,-y), 2(+z,-z)
        int invDirection = Mathf.Abs(direction - (axis * 2 + 1)) + (axis * 2);

        /*
            direction    x0    abs(x0)    abs(x) + axis * 2 => invDirection
            0            -1    1          1  
            1            0     0          0
            2            -1    1          3
            3            0     0          2
            4            -1    1          5
            5            0     0          4
            */

        return invDirection;
    }

    public static int Mod(int v, int m)
    {
        int r = v % m;
        return r < 0 ? r + m : r;
    }

    public static int3 Mod(int3 v, int3 m)
    {
        return new int3
        {
            x = Mod(v.x, m.x),
            y = Mod(v.y, m.y),
            z = Mod(v.z, m.z)
        };
    }

    public static int Floor(float x)
    {
        int xi = (int)x;
        return x < xi ? xi - 1 : xi;
    }

    public static int3 Floor(float3 v)
    {
        return new int3
        {
            x = Floor(v.x),
            y = Floor(v.y),
            z = Floor(v.z)
        };
    }

    public static readonly int[] DirectionAlignedX = { 2, 2, 0, 0, 0, 0 };
    public static readonly int[] DirectionAlignedY = { 1, 1, 2, 2, 1, 1 };
    public static readonly int[] DirectionAlignedZ = { 0, 0, 1, 1, 2, 2 };
    public static readonly int[] DirectionAlignedSign = { 1, -1, 1, -1, 1, -1 };

    public static readonly int3[] VoxelDirectionOffsets =
    {
        new int3(1, 0, 0), // right
        new int3(-1, 0, 0), // left
        new int3(0, 1, 0), // top
        new int3(0, -1, 0), // bottom
        new int3(0, 0, 1), // front
        new int3(0, 0, -1), // back
    };

    public static readonly float3[] CubeVertices =
    {
        new float3(0f, 0f, 0f),
        new float3(1f, 0f, 0f),
        new float3(1f, 0f, 1f),
        new float3(0f, 0f, 1f),
        new float3(0f, 1f, 0f),
        new float3(1f, 1f, 0f),
        new float3(1f, 1f, 1f),
        new float3(0f, 1f, 1f)
    };

    public static readonly int[] CubeFaces =
    {
        1, 2, 5, 6, // right
        0, 3, 4, 7, // left
        4, 5, 7, 6, // top
        0, 1, 3, 2, // bottom
        3, 2, 7, 6, // front
        0, 1, 4, 5, // back
    };

    public static readonly float2[] CubeUVs =
    {
        new float2(0f, 0f), new float2(1.0f, 0f), new float2(0f, 1.0f), new float2(1.0f, 1.0f)
    };

    public static readonly int[] CubeIndices =
    {
        0, 3, 1,
        0, 2, 3, //face right
        1, 3, 0,
        3, 2, 0, //face left
        0, 3, 1,
        0, 2, 3, //face top
        1, 3, 0,
        3, 2, 0, //face bottom
        1, 3, 0,
        3, 2, 0, //face front
        0, 3, 1,
        0, 2, 3, //face back
    };

    public static readonly int[] CubeFlipedIndices =
    {
        0, 2, 1,
        1, 2, 3, //face right
        1, 2, 0,
        3, 2, 1, //face left
        0, 2, 1,
        1, 2, 3, //face top
        1, 2, 0,
        3, 2, 1, //face bottom
        1, 2, 0,
        3, 2, 1, //face front
        0, 2, 1,
        1, 2, 3, //face back
    };

    public static readonly int[] AONeighborOffsets =
    {
        0, 1, 2,
        6, 7, 0,
        2, 3, 4,
        4, 5, 6,
    };
}
---


В проекте так же есть:
- Character.meta (D:/Unity Project/Testgame/Assets/Scripts\Character.meta)
- ItemSys.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys.meta)
- SaveSys.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys.meta)
- TerrainManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\TerrainManager.cs.meta)
- Utils.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils.meta)
- VoxelSys.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys.meta)
- CameraController.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\CameraController.cs.meta)
- Interaction.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction.meta)
- PlayerBumper.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerBumper.cs.meta)
- PlayerController.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerController.cs.meta)
- PlayerManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerManager.cs.meta)
- PlayerStats.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\PlayerStats.cs.meta)
- SceneStarter.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\SceneStarter.cs.meta)
- VoxelPlacer.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\VoxelPlacer.cs.meta)
- IInteractable.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\IInteractable.cs.meta)
- InteractionManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\InteractionManager.cs.meta)
- PlayerInteraction.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Character\Interaction\PlayerInteraction.cs.meta)
- Containers.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers.meta)
- ItemDatabase.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemDatabase.cs.meta)
- ItemStack.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemStack.cs.meta)
- ItemTypes.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes.meta)
- ItemUtil.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemUtil.cs.meta)
- SpawnManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\SpawnManager.cs.meta)
- UI.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI.meta)
- WorldObjects.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\WorldObjects.meta)
- ContainerManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ContainerManager.cs.meta)
- Inventory.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\Inventory.cs.meta)
- ItemContainer.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ItemContainer.cs.meta)
- ItemStash.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\Containers\ItemStash.cs.meta)
- Block.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Block.cs.meta)
- Equiment.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Equiment.cs.meta)
- Item.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\Item.cs.meta)
- NPC.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\ItemTypes\NPC.cs.meta)
- EquipmentSlot.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\EquipmentSlot.cs.meta)
- ImageController.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\ImageController.cs.meta)
- ItemSlot.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\ItemSlot.cs.meta)
- Tooltip.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\Tooltip.cs.meta)
- UIUtil.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\UI\UIUtil.cs.meta)
- WorldObject.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\ItemSys\WorldObjects\WorldObject.cs.meta)
- DataClasses.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\DataClasses.meta)
- LoadMenu.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\LoadMenu.cs.meta)
- NewSaveMenu.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\NewSaveMenu.cs.meta)
- PauseMenu.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\PauseMenu.cs.meta)
- SaveManager.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveManager.cs.meta)
- SaveMenu.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveMenu.cs.meta)
- SaveUtil.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\SaveUtil.cs.meta)
- WorldPlacementData.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\SaveSys\DataClasses\WorldPlacementData.cs.meta)
- CollisionChecker.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\CollisionChecker.cs.meta)
- Main.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main.meta)
- MouseHandler.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\MouseHandler.cs.meta)
- NativeCounter.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\NativeCounter.cs.meta)
- NativeHelper.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\NativeHelper.cs.meta)
- NoAllocHelpers.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\NoAllocHelpers.cs.meta)
- Noise.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Noise.cs.meta)
- PriorityQueue.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue.meta)
- SerializePropertyReadOnly.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\SerializePropertyReadOnly.cs.meta)
- Singleton.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Singleton.cs.meta)
- Consts.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\Consts.cs.meta)
- GameController.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\GameController.cs.meta)
- GameEvents.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\Main\GameEvents.cs.meta)
- FastPriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\FastPriorityQueue.cs.meta)
- FastPriorityQueueNode.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\FastPriorityQueueNode.cs.meta)
- GenericPriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\GenericPriorityQueue.cs.meta)
- GenericPriorityQueueNode.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\GenericPriorityQueueNode.cs.meta)
- IFixedSizePriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\IFixedSizePriorityQueue.cs.meta)
- IPriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\IPriorityQueue.cs.meta)
- SimplePriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\SimplePriorityQueue.cs.meta)
- StablePriorityQueue.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\StablePriorityQueue.cs.meta)
- StablePriorityQueueNode.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\Utils\PriorityQueue\StablePriorityQueueNode.cs.meta)
- Chunk.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\Chunk.cs.meta)
- ChunkColliderBuilder.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkColliderBuilder.cs.meta)
- ChunkMeshBuilder.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkMeshBuilder.cs.meta)
- ChunkObjectSpawner.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkObjectSpawner.cs.meta)
- ChunkPersistance.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\ChunkPersistance.cs.meta)
- NoiseGenerator.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\NoiseGenerator.cs.meta)
- TerrainPersistance.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\TerrainPersistance.cs.meta)
- Voxel.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\Voxel.cs.meta)
- VoxelUtil.cs.meta (D:/Unity Project/Testgame/Assets/Scripts\VoxelSys\VoxelUtil.cs.meta)

    </pre>
</body>
</html>